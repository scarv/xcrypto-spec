\subsection{\XCID instructions}
\label{sec:spec:instruction}

% =============================================================================

\subsubsection{Class-$1$:   baseline}
\label{sec:spec:instruction:1}

% -----------------------------------------------------------------------------

\XCINSTR{xc.xcr2gpr}{rd, crs1}{
  Move an $\XCR$ register to a $\GPR$ register.
}{ 
  $\GPR[*][{\VERB[RV]{rd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gpr2xcr}{crd, rs1}{
  Move a $\GPR$ register to an $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \GPR[*][{\VERB[RV]{rs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.cmov.t}{crd, crs1, crs2}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] \neq 0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.cmov.f}{crd, crs1, crs2}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] =    0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.bu}{crd, h, b, imm11(rs1)}{
  Load a     byte from memory
  into a specific     byte of an $\XCR$ register.
  If \VERB[RV]{h} or \VERB[RV]{b} are non-zero,
  the other bytes in the destination register are left un-modified.
  If \VERB[RV]{h} and \VERB[RV]{b} are zero,
  the least-significant byte of the destination register
  is set to the loaded byte, and all other bytes in the
  destination register are cleared.
}{
  $addr                                          \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index                                         \ASN ( \VERB[RV]{cc} \CONS \VERB[RV]{cd} ) \XOR 0$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  } \ASN \MEM[*][{addr  }]$ \;
  \If{$index = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.hu}{crd, h,    imm11(rs1)}{
  Load a halfword from memory
  into a specific halfword of an $\XCR$ register,
  If \VERB[RV]{h} is non-zero,
  the low halfword of the destination register is left un-modified.
  If \VERB[RV]{h} is zero,
  the least-significant halfword of the destination register
  is set to the loaded halfword, and all other halfwords in the
  destination register are cleared.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0                                       \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 0$ \;
  $index_1                                       \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 1$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1} \ASN \MEM[*][{addr+1}]$ \;
  \If{$index_0 = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.w} {crd,        imm11(rs1)}{
  Load a     word from memory 
  into                        an $\XCR$ register.
}{
  $addr                                          \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0                                       \ASN                                            0$ \;
  $index_1                                       \ASN                                            1$ \;
  $index_2                                       \ASN                                            2$ \;
  $index_3                                       \ASN                                            3$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1} \ASN \MEM[*][{addr+1}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_2} \ASN \MEM[*][{addr+2}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_3} \ASN \MEM[*][{addr+3}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.b} {rs2, h, b, imm11(rs1)}{
  Store a specific     byte of an $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index           \ASN ( \VERB[RV]{cc} \CONS \VERB[RV]{cd} ) \XOR 0$ \;
  $\MEM[*][addr  ] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  }$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.h} {rs2, h,    imm11(rs1)}{
  Store a specific halfword of an $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0         \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 0$ \;
  $index_1         \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 1$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.w} {rs2,       imm11(rs1)}{
  Store                        an $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0         \ASN                                            0$ \;
  $index_1         \ASN                                            1$ \;
  $index_2         \ASN                                            2$ \;
  $index_3         \ASN                                            3$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1}$ \;
  $\MEM[*][addr+2] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_2}$ \;
  $\MEM[*][addr+3] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_3}$ \;
}

% =============================================================================

\subsubsection{Class-$2.1$: randomness}
\label{sec:spec:instruction:2:1}

\XCINSTR{xc.rngtest}{rd1}{
  Inspect the RNG state, applying a suitable ``health check'' on the level 
  of entropy available: the status flag is stored in a $\GPR$ register.
  If, after execution \VERB[RV]{xc.rngseed},
         $\GPR[*][{\VERB[RV]{rd1}}] \neq 0$
  (resp. $\GPR[*][{\VERB[RV]{rd1}}] =    0$),
  then the RNG has 
           sufficient 
  (resp. insufficient)
  entropy; the next output sampled via \VERB[RV]{xc.rngsamp} 
  therefore
         can
  (resp. cannot, or at least should not)
  be used.
}{
  $\GPR[*][{\VERB[RV]{rd1}}] \TEST{\ASN} \RNG$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.rngseed}{crs1}{
  Inject (or seed) $32$-bits of entropy into the RNG, reading from an $\XCR$ register.
}{
  $\RNG \ASN \XCR[*][{\VERB[RV]{crs1}}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.rngsamp}{crd}{
  Sample           $32$-bits of entropy from the RNG, writing to   an $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \RNG$ \;
}

% =============================================================================

\subsubsection{Class-$2.2$: memory}
\label{sec:spec:instruction:2:2}

These instructions allow multiple non-contiguous memory loads and stores
to be performed by a single instruction.
For a given data width, the instructions load or store one registers
worth of that data width to arbitrary addresses based on offsets stored
in another register.
This means that each instruction generates multiple memory transactions.
Implementations must adhere to the following rules with regard
to exceptions.
\begin{itemize}
\item Instructions in this class follow the normal rules for raising
    address misalignment exceptions as defined in the base RISC-V ISA.
\item All memory addresses generated by these instructions must
    be checked for misalignment {\em before} any memory transactions are
    issued.
\begin{itemize} \item
    For example, if the second transaction were to a misaligned address,
    the first transaction must not be issued.
    This restriction prevents any side effects out in the memory hierarchy
    and partial execution results from misaligned accesses.
    If the platform supports misaligned accesses, this case need not
    be considered.
\end{itemize}
\item Each memory transaction has the potential to generate an access
    fault which cannot be predicted until after the memory transaction
    has been issued.
    This may be a page fault or bus fault.
\begin{itemize}
\item In this case, partial execution results are not permitted.
    The destination register may not be updated unless all of the
    memory transactions complete successfully.
\item In the case of a page or bus fault, side effects in the
    memory hierarchy are permitted, though they should be avoided if
    possible.
\end{itemize}
\end{itemize}

% -----------------------------------------------------------------------------

\XCINSTR{xc.scatter.b}{crd, crs2, rs1}{
  Perform a ``scattered'' store of 
  four     bytes 
  from an $\XCR$ register
  into memory;
  for the $i$-th store, a base-offset style effective address is formed 
  from a
                    a  $\GPR$ register (the   base)
  plus
  a     byte within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\MEM[*][addr_0  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_1  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_2  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_3  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.scatter.h}{crd, crs2, rs1}{
  Perform a ``scattered'' store of 
  two  halfwords
  from an $\XCR$ register
  into memory;
  for the $i$-th store, a base-offset style effective address is formed 
  from a
                    a  $\GPR$ register (the   base)
  plus
  a halfword within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\MEM[*][addr_0+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_0+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_1+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_1+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gather.b}{crd, crs2, rs1}{
  Perform a  ``gathered''  load of 
  four     bytes 
  from memory 
  into an $\XCR$ register;
  for the $i$-th  load, a base-offset style effective address is formed 
  from a
                    a  $\GPR$ register (the   base)
  plus
  a     byte within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_1  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_2  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_3  ]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gather.h}{crd, crs2, rs1}{
  Perform a  ``gathered''  load of 
  two  halfwords
  from memory 
  into an $\XCR$ register;
  for the $i$-th  load, a base-offset style effective address is formed 
  from a
                    a  $\GPR$ register (the   base)
  plus
  a halfword within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_0+1]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_1+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_1+1]$ \;
}

% =============================================================================

\subsubsection{Class-$2.3$: bit-oriented}
\label{sec:spec:instruction:2:3}

\XCINSTR{xc.ld.liu}{crd, imm16}{
  Load an immediate halfword
  into the lower (or least-significant) halfword of an $\XCR$ register, 
  leaving the other halfword in said register un-modified.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.hiu}{crd, imm16}{
  Load an immediate halfword
  into the upper (or  most-significant) halfword of an $\XCR$ register, 
  leaving the other halfword in said register un-modified.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.bop}{crd, crs1, crs2, lut8}{
  Compute each $i$-bit of a $32$-bit result by applying a given $3$-input, 
  $1$-output Boolean function $f$ to corresponding $i$-th bits of the three
  operands.
  
  The function $f$ is specified as a truth-table encoded as the
  immediate \VERB[RV]{lut8}: given
  \[
  \begin{array}{|ccc|c|}
  \hline
  \multicolumn{4}{|c|}{f}     \\
  \hline
  x_i & y_i & z_i & r_i               \\
  \hline
    0 & 0 &   0 & \VERB[RV]{lut8}_0 \\
    0 & 0 &   1 & \VERB[RV]{lut8}_1 \\
    0 & 1 &   0 & \VERB[RV]{lut8}_2 \\
    0 & 1 &   1 & \VERB[RV]{lut8}_3 \\
    1 & 0 &   0 & \VERB[RV]{lut8}_4 \\
    1 & 0 &   1 & \VERB[RV]{lut8}_5 \\
    1 & 1 &   0 & \VERB[RV]{lut8}_6 \\
    1 & 1 &   1 & \VERB[RV]{lut8}_7 \\
  \hline
  \end{array}
  \]
  the instruction essentially computes
  $
  \INDEX{r}{i} = f( \INDEX{x}{i}, \INDEX{y}{i}, \INDEX{z}{i} ) = \INDEX{\VERB[RV]{lut8}}{x_i \CONS y_i \CONS z_i}
  $
  for $x$, $y$, $z$ and $r$, all in $\XCR$ registers.
  Note that
  \VERB[RV]{xc.bop}
  allows synthesis of a wider set of functionality; 
  for example, it can be used to synthesise a set of standard Boolean
  instructions (e.g., those in RV32I) by padding 
  \VERB[RV]{lut8} 
  appropriately per
  \[
  \begin{array}{l@{\;}c@{\;}l c l@{\;}c@{\;}l}
  \VERB[RV]{lut8} &=& \RADIX{10001000}{2} &\Longrightarrow& f &=& x \AND y \\
  \VERB[RV]{lut8} &=& \RADIX{11101110}{2} &\Longrightarrow& f &=& x \IOR y \\
  \VERB[RV]{lut8} &=& \RADIX{01100110}{2} &\Longrightarrow& f &=& x \XOR y \\
  \end{array}
  \]
}{
  \For{$i = 0$ {\bf upto} $31$} {
    $index \ASN \INDEX{\XCR[*][crd]}{i} \CONS \INDEX{\XCR[*][crs1]}{i} \CONS \INDEX{\XCR[*][crs2]}{i}$ \;
    $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{\VERB[RV]{lut8}}{index}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ext}{crd, crs, lo, hi}{
  Extract a contiguous sequences of $2$-bit crumbs 
  from             one $\XCR$ register, and
  insert them as the LSBs in another $\XCR$ register.
}{
  $lo \ASN 2 \cdot \VERB[RV]{cs}         $ \;
  $hi \ASN 2 \cdot \VERB[RV]{cl} + lo - 1$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{( 2 \cdot \VERB[RV]{cl} - 1 ) \RANGE 0} \ASN \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{hi \RANGE lo}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ins}{crd, crs, lo, hi}{
  Extract a contiguous sequences of $2$-bit crumbs 
  from the LSBs of one $\XCR$ register, and
  insert   them           in another $\XCR$ register.
}{
  $lo \ASN 2 \cdot \VERB[RV]{cs}         $ \;
  $hi \ASN 2 \cdot \VERB[RV]{cl} + lo - 1$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{hi \RANGE lo}$ \ASN \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{( 2 \cdot \VERB[RV]{cl} - 1 ) \RANGE 0} \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mix.l}{crd, crs1, crs2, rtamt}{
  Form a result by mix together bits from two operands based on a mask:
  the instruction essentially computes  
  \[
  \INDEX{r}{i} = \left\{\begin{array}{ll}
                        \INDEX{x}{i} \OP[32][u]{\RRT}   \VERB[RV]{rtamt}        & \mbox{~if $\INDEX{m}{i} = 1$} \\
                        \INDEX{r}{i}                                            & \mbox{~otherwise            } \\
                        \end{array}
                        \right.
  \]
  for $r$, $x$, and $m$ in $\XCR$ registers,
  and for each 
  $
  0 \leq i < 32 .
  $ 
}{
  $t \ASN \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\RRT}   \VERB[RV]{rtamt}       $ \;
  \For{$i = 0$ {\bf upto} $31$}{
    \If{$\INDEX{\XCR[*][{\VERB[RV]{crs2}}]}{i} = 1$}{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{t}{i}$
    }
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mix.h}{crd, crs1, crs2, rtamt}{
  Form a result by mix together bits from two operands based on a mask:
  the instruction essentially computes  
  \[
  \INDEX{r}{i} = \left\{\begin{array}{ll}
                        \INDEX{x}{i} \OP[32][u]{\RRT} ( \VERB[RV]{rtamt} + 16 ) & \mbox{~if $\INDEX{m}{i} = 1$} \\
                        \INDEX{r}{i}                                            & \mbox{~otherwise            } \\
                        \end{array}
                        \right.
  \]
  for $r$, $x$, and $m$ in $\XCR$ registers,
  and for each 
  $
  0 \leq i < 32 .
  $ 
}{
  $t \ASN \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\RRT} ( \VERB[RV]{rtamt} + 16 )$ \;
  \For{$i = 0$ {\bf upto} $31$}{
    \If{$\INDEX{\XCR[*][{\VERB[RV]{crs2}}]}{i} = 1$}{
      $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{t}{i}$
    }
  }
}


% -----------------------------------------------------------------------------

\XCINSTR{xc.lut}{crd, crs1, crs2, crs3}{
  Apply an arbitrary $4$-bit input, $4$-bit output Look-up Table (LUT) 
  to the contents of 
  $\XCR[*][{\VERB[RV]{crs1}}]$,
  placing the result in
  $\XCR[*][{\VERB[RV]{crd}}]$.
  The LUT is specified by
  $
  \XCR[*][{\VERB[RV]{crs2}}]$ and $\XCR[*][{\VERB[RV]{crs3}}] ,
  $
  allowing definition of
  \[
  lut[i] = \INDEX[4]{{(\XCR[*][{\VERB[RV]{crs3}}] \CONS \XCR[*][{\VERB[RV]{crs2}}])}}{i}
  \]
  for each $0 \leq i < 15$.  For example, if 
  $
  \XCR[*][{\VERB[RV]{crs2}}] = \RADIX{ABCD1234}{16}
  $
  and
  $
  \XCR[*][{\VERB[RV]{crs3}}] = \RADIX{456789EF}{16}
  $
  then 
  $lut[0] = \RADIX{4}{16}$, 
  $lut[1] = \RADIX{3}{16}$,
  $lut[7] = \RADIX{A}{16}$ 
  and 
  $lut[8] = \RADIX{F}{16}$.

  Note that
  \VERB[RV]{xc.lut}
  allows synthesis of a wider set of functionality; 
  for example, application of a $2$-bit input, $2$-bit output LUT can 
  be synthesised by padding
  $
  \XCR[*][{\VERB[RV]{crs2}}]$ and $\XCR[*][{\VERB[RV]{crs3}}]
  $
  appropriately.
}{
  \For{$i=0$ {\bf upto} $15$}{
    \INDEX[4]{\XCR[*][{\VERB[RV]{crd}}]}{i} = lut[\INDEX[4]{\XCR[*][{\VERB[RV]{crs1}}]}{i}]
  }
}

% =============================================================================

\subsubsection{Class-$2.4$: packed}
\label{sec:spec:instruction:2:4}

Each instruction in this class computes a packed operation: for an operator
$\odot$, register or immediate variants essentially compute

\begin{enumerate}
\item $\INDEX[w]{r}{i} = \INDEX[w]{x}{i} \OP[w][u]{\odot} \INDEX[w]{y}{i}$,
      for $r$, $x$, and $y$ in $\XCR$ registers.
      and
\item $\INDEX[w]{r}{i} = \INDEX[w]{x}{i} \OP[w][u]{\odot}           y    $,
      for $r$       and $x$ in $\XCR$ registers, and an immediate $y$,
\end{enumerate}

\noindent
and for each 
$
0 \leq i < \VERB[RV]{n} ,
$ 
where the field count
$
\VERB[RV]{n} \in \SET{ 2, 4, 8, 16, 32 }
$ 
specified in the instruction encoding implies a field width of 
$
w = 32 / \VERB[RV]{n} .
$
As such, said encoding yields the following cases
\[
\begin{array}{ccrcc@{\;}c@{\;}rc@{\;}c@{\;}r}
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{000}{2} &\mapsto& \VERB[RV]{n} &=&  1 & w &=& 32     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{001}{2} &\mapsto& \VERB[RV]{n} &=&  2 & w &=& 16     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{010}{2} &\mapsto& \VERB[RV]{n} &=&  4 & w &=&  8     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{011}{2} &\mapsto& \VERB[RV]{n} &=&  8 & w &=&  4     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{100}{2} &\mapsto& \VERB[RV]{n} &=&  1 & w &=& 32     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{101}{2} &\mapsto& \VERB[RV]{n} &=& 16 & w &=&  2     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{110}{2} &\mapsto& \multicolumn{6}{c}{\mbox{invalid}} \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{111}{2} &\mapsto& \multicolumn{6}{c}{\mbox{invalid}} \\
\end{array}
\]
where cases marked invalid are reserved.  Note that the encoding 
$
\RADIX{100}{2}
$
is valid only for the instructions
\VERB[RV]{xc.psll.i},
\VERB[RV]{xc.psrl.i} and
\VERB[RV]{xc.prot.i}.
In this case, the \VERB[RV]{ca} bit is used to encode the most significant
bit of the shift/rotate amount; for all other instructions, the encoding
is considered invalid.

% -----------------------------------------------------------------------------

\XCINSTR{xc.padd}{pw, crd, crs1, crs2}{
  Compute a   register-based packed addition, 
  implying $\odot = +$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{+}      \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psub}{pw, crd, crs1, crs2}{
  Compute a   register-based packed subtraction, 
  implying $\odot = -$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{-}      \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pmul.l}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication,
  implying $\odot = \times$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the  ``low'' half, or $w$ LSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pmul.h},   which captures the ``high'' half, or $w$ MSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{ \times} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{        w - 1 \RANGE 0}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pmul.h}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication,
  implying $\odot = \times$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the ``high'' half, or $w$ MSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pmul.l},   which captures the  ``low'' half, or $w$ LSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{ \times} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{2 \cdot w - 1 \RANGE w}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pclmul.l}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication in $\B{F}_2[\IND{x}]$ (or ``carry-less'' multiplication),
  implying $\odot = \otimes$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the  ``low'' half, or $w$ LSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pclmul.h}, which captures the ``high'' half, or $w$ MSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\otimes} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{        w - 1 \RANGE 0}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pclmul.h}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication in $\B{F}_2[\IND{x}]$ (or ``carry-less'' multiplication),
  implying $\odot = \otimes$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the ``high'' half, or $w$ MSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pclmul.l}, which captures the  ``low'' half, or $w$ LSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\otimes} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{2 \cdot w - 1 \RANGE w}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psll}{pw, crd, crs1, crs2}{
  Compute a   register-based packed left-shift,
  implying $\odot = \LSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LSH}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psll.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed left-shift,
  implying $\odot = \LSH$.
  Note that any out-of-range distance
  $
  \VERB[RV]{shamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
  Valid shift amounts for field width $w=32$ are $0 \le x \le 31$.
  Valid shift amounts for field widths $w<32$ are $0 \le x \le 15$.
  When $w=32$, the {\tt ca} field is used to encode the MSB of the shift amount.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \eIf{$w = 32$}{
    $shamt = ca \CONS cshamt $\;
  }{
    $shamt = 0  \CONS cshamt $\;
  }
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LSH}   \VERB[RV]{shamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psrl}{pw, crd, crs1, crs2}{
  Compute a   register-based packed right-shift,
  implying $\odot = \RSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RSH}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psrl.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed left-shift,
  implying $\odot = \RSH$.
  Note that any out-of-range distance
  $
  \VERB[RV]{shamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
  Valid shift amounts for field width $w=32$ are $0 \le x \le 31$.
  Valid shift amounts for field widths $w<32$ are $0 \le x \le 15$.
  When $w=32$, the {\tt ca} field is used to encode the MSB of the shift amount.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \eIf{$w = 32$}{
    $shamt = ca \CONS cshamt $\;
  }{
    $shamt = 0  \CONS cshamt $\;
  }
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RSH}   \VERB[RV]{shamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.prot}{pw, crd, crs1, crs2}{
  Compute a   register-based packed right-rotate,
  implying $\odot = \RRT$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that the effective distance is
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \pmod{w} .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RRT}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.prot.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed right-rotate,
  implying $\odot = \RRT$.
  Note that the effective distance is
  $
  \VERB[RV]{rtamt} \pmod{w} .
  $
  Valid shift amounts for field width $w=32$ are $0 \le x \le 31$.
  Valid shift amounts for field widths $w<32$ are $0 \le x \le 15$.
  When $w=32$, the {\tt ca} field is used to encode the MSB of the shift amount.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \eIf{$w = 32$}{
    $rtamt = ca \CONS cshamt $\;
  }{
    $rtamt = 0  \CONS cshamt $\;
  }
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RRT}   \VERB[RV]{rtamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pperm.w}{crd, crs1, b0, b1, b2, b3}{
  Permute bytes   of               some $\XCR$ register,
  storing the result in               another $\XCR$ register.
}{
  $t \ASN            \XCR[*][{\VERB[RV]{crs}}]               $ \;
  $           \XCR[*][{\VERB[RV]{crd}}]                \ASN \INDEX[ 8]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 8]{t}{\VERB[RV]{b0}} $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pperm.hx}{crd, crs1, b0, b1, b2, b3}{
  Permute nibbles of a halfword in some $\XCR$ register,
  storing the result in a halfword of another $\XCR$ register.
  Note that the index 
  $
  \VERB[RV]{x} \in \SET{ 0, 1 }
  $
  is part of the opcode (and hence mnemonic).
}{
  $t \ASN \INDEX[16]{\XCR[*][{\VERB[RV]{crs}}]}{\VERB[RV]{x}}$ \;
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{x}} \ASN \INDEX[ 4]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 4]{t}{\VERB[RV]{b0}} $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pperm.bx}{crd, crs1, b0, b1, b2, b3}{
  Permute crumbs  of a byte     in some $\XCR$ register,
  storing the result in a byte     of another $\XCR$ register.
  Note that the index 
  $
  \VERB[RV]{x} \in \SET{ 0, 1, 2, 3 }
  $
  is part of the opcode (and hence mnemonic).
}{
  $t \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs}}]}{\VERB[RV]{x}}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{\VERB[RV]{x}} \ASN \INDEX[ 2]{t}{\VERB[RV]{b3}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b2}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b1}} \CONS
                                                            \INDEX[ 2]{t}{\VERB[RV]{b0}} $ \;
}

% =============================================================================

\subsubsection{Class-$2.5$: multi-precision}
\label{sec:spec:instruction:2:5}

Instructions in this class use upto
$4$ source      $\XCR$ registers
and
$2$ destination $\XCR$ registers,
which demands some compromises wrt. the encoding used.
In short, a compressed specification of the destination $\XCR$ registers is
used, whereby a single encoded \VERB[RV]{crdm} field implies (or maps to) a 
pair 
$
\TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} }
$
of register addresses st.
a) $\VERB[RV]{crd2} = \VERB[RV]{crd1} + 1$
   (the contiguous'ness rule),
   and
b) $\VERB[RV]{crd2} = 1 \pmod{2}$
   and 
   $\VERB[RV]{crd1} = 0 \pmod{2}$
   (the  odd-even'ness rule).
Concretely then, this means
\[
\begin{array}{l@{\;}c@{\;}r c c@{\;}l@{\;}c@{\;}r@{\;}c@{\;}l@{\;}c@{\;}r@{\;}c}
\VERB[RV]{crdm} &=& \RADIX{000}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  1 &,& \VERB[RV]{crd1} &=&  0 & ) \\
\VERB[RV]{crdm} &=& \RADIX{001}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  3 &,& \VERB[RV]{crd1} &=&  2 & ) \\
\VERB[RV]{crdm} &=& \RADIX{010}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  5 &,& \VERB[RV]{crd1} &=&  4 & ) \\
\VERB[RV]{crdm} &=& \RADIX{011}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  7 &,& \VERB[RV]{crd1} &=&  6 & ) \\
\VERB[RV]{crdm} &=& \RADIX{100}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  9 &,& \VERB[RV]{crd1} &=&  8 & ) \\
\VERB[RV]{crdm} &=& \RADIX{101}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 11 &,& \VERB[RV]{crd1} &=& 10 & ) \\
\VERB[RV]{crdm} &=& \RADIX{110}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 13 &,& \VERB[RV]{crd1} &=& 12 & ) \\
\VERB[RV]{crdm} &=& \RADIX{111}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 15 &,& \VERB[RV]{crd1} &=& 14 & ) \\
\end{array}
\]
i.e.,
\[
\VERB[RV]{crdm} = x ~~\mapsto~~ \TUPLE{ \VERB[RV]{crd2} = x \CONS 1 , \VERB[RV]{crd1} = x \CONS 0 } ,
\]
noting
$\TUPLE{ 1, 0 }$ and $\TUPLE{ 3, 2 }$ are deemed valid pairs,
$\TUPLE{ 3, 0 }$ is invalid because it violates the contiguous'ness rule,
$\TUPLE{ 2, 3 }$ is invalid because it violates the contiguous'ness rule,
and
$\TUPLE{ 2, 1 }$ is invalid because it violates the  odd-even'ness rule.

% -----------------------------------------------------------------------------

\XCINSTR{xc.madd.2}{(crd2, crd1), crs1, crs2      }{
  Compute a   register-based multi-precision (or ``long'') addition:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the addends,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the sum,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the carry-out,
  meaning the instruction acts as a word-oriented analogue of a half-adder.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.madd.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') addition:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the addends,
  $\XCR[*][{\VERB[RV]{crs3}}]$ as the carry-in,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the sum,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the carry-out,
  meaning the instruction acts as a word-oriented analogue of a full-adder.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{+} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msub.2}{(crd2, crd1), crs1, crs2      }{
  Compute a   register-based multi-precision (or ``long'') subtraction:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$ as the    minuend,
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the subtrahend,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the difference,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the borrow-out,
  meaning the instruction acts as a word-oriented analogue of a half-subtractor.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msub.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') subtraction:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$ as the    minuend,
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the subtrahend,
  $\XCR[*][{\VERB[RV]{crs3}}]$ as the borrow-in,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the difference,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the borrow-out,
  meaning the instruction acts as a word-oriented analogue of a full-subtractor.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{-} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.macc.1}{(crd2, crd1), crs1      }{
  Compute a   register-based multi-precision (or ``long'') accumulation,
  with the
  $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs1}}]$
  accumulated into a $64$-bit value formed by concatenating
  $\XCR[*][{\VERB[RV]{crd1}}]$
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.macc.2}{(crd2, crd1), crs1, crs2}{
  Compute a   register-based multi-precision (or ``long'') accumulation,
  with the
  $32$-bit addends
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  accumulated into a $64$-bit value formed by concatenating
  $\XCR[*][{\VERB[RV]{crd1}}]$
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}] 
                                                                                                   \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs2}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mmul.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') multiply-accumulate:
  the $32$-bit multiplicands
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  are first used to form a $64$-bit product captured by
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs),
  into which the $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs3}}]$
  is accumulated.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{ \times} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{ +}      \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mclmul.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') multiply-accumulate in $\B{F}_2[\IND]$:
  the $32$-bit multiplicands
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  are first used to form a $64$-bit product captured by
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs),
  into which the $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs3}}]$
  is accumulated.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\otimes} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{\oplus}  \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msll}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'')  left-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then  left-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs3}}]}{i} \geq 64
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd1}}]}{i} = \INDEX[w]{\XCR[*][{\VERB[RV]{crd2}}]}{i} = 0 .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\LSH} \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msll.i}{(crd2, crd1), crs1, crs2, shamt}{
  Compute an immediate-based multi-precision (or ``long'')  left-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then  left-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\LSH} \VERB[RV]{cmshamt}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msrl}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') right-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then right-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs3}}]}{i} \geq 64
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd1}}]}{i} = \INDEX[w]{\XCR[*][{\VERB[RV]{crd2}}]}{i} = 0 .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\RSH} \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msrl.i}{(crd2, crd1), crs1, crs2, shamt}{
  Compute an immediate-based multi-precision (or ``long'') right-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then right-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\RSH} \VERB[RV]{cmshamt}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mequ}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
  equality 
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_0            \AND \GPR[*][{\VERB[RV]{rs1}}]  $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mlte}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
     less-than
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $t_1 \ASN \XCR[*][{\VERB[RV]{crs2}}] < \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_1 \IOR ( t_0 \AND \GPR[*][{\VERB[RV]{rs1}}] )$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mgte}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
  greater-than
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $t_1 \ASN \XCR[*][{\VERB[RV]{crs2}}] > \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_1 \IOR ( t_0 \AND \GPR[*][{\VERB[RV]{rs1}}] )$ \;
}

% -----------------------------------------------------------------------------

\subsubsection{Class-$3.1$: AES}
\label{sec:spec:instruction:3:1}

\XCINSTR{xc.aessub}{mode, rot, crd, crs1, crs2}{
  Per~\cite[Figures 5]{SCARV:TilGro:06}, 
  apply a (carefully structured) form of the AES 
  {\tt SubBytes}~\cite[Section 5.1.1]{SCARV:FIPS:197}
  operation:
  this is applicable to a column-oriented implementation of AES, whereby
  columns of the state (resp. round key) matrix are packed into $32$-bit
  words.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{mode}
  $
  and
  $
  \VERB[RV]{rot}
  $
  control  which variant is applied: these variants are exposed via
  dedicated mnemonics st.
  \[
  \begin{array}{l c r@{\;}c@{\;}l @{\;}c@{\;} r@{\;}c@{\;}l}
  \VERB[RV]{xc.aessub.enc}    &\mapsto& \VERB[RV]{mode} &=& 0 &,& \VERB[RV]{rot} &=& 0 \\
  \VERB[RV]{xc.aessub.encrot} &\mapsto& \VERB[RV]{mode} &=& 0 &,& \VERB[RV]{rot} &=& 1 \\
  \VERB[RV]{xc.aessub.dec}    &\mapsto& \VERB[RV]{mode} &=& 1 &,& \VERB[RV]{rot} &=& 0 \\
  \VERB[RV]{xc.aessub.decrot} &\mapsto& \VERB[RV]{mode} &=& 1 &,& \VERB[RV]{rot} &=& 1 \\
  \end{array}
  \]
  $\VERB[RV]{mode}$ is encoded in the $\VERB[RV]{ca}$ field and
  $\VERB[RV]{rot}$  is encoded in the $\VERB[RV]{cb}$ field.
}{
  \eIf{$\VERB[RV]{mode} = 0$}{
    $t_0                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][\OPER{crs1}]_{ 7 \RANGE  0} )$ \;
    $t_1                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][\OPER{crs2}]_{15 \RANGE  8} )$ \;
    $t_2                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][\OPER{crs1}]_{23 \RANGE 16} )$ \;
    $t_3                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][\OPER{crs2}]_{31 \RANGE 24} )$ \;
  }{
    $t_0                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][\OPER{crs1}]_{ 7 \RANGE  0} )$ \;
    $t_1                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][\OPER{crs2}]_{15 \RANGE  8} )$ \;
    $t_2                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][\OPER{crs1}]_{23 \RANGE 16} )$ \;
    $t_3                 \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][\OPER{crs2}]_{31 \RANGE 24} )$ \;
  }
  
  \eIf{$\VERB[RV]{rot}  = 0$}{
    $\XCR[*][\OPER{crd0}] \ASN                                          t_3 \CONS t_2 \CONS t_1 \CONS t_0 $ \;
  }{
    $\XCR[*][\OPER{crd0}] \ASN                                          t_2 \CONS t_1 \CONS t_0 \CONS t_3 $ \;
  }
}

\XCINSTR{xc.aesmix}{mode,      crd, crs1, crs2}{
  Per~\cite[Figures 5]{SCARV:TilGro:06}, 
  apply a (carefully structured) form of the AES 
  {\tt ShiftRows}~\cite[Section 5.1.2]{SCARV:FIPS:197} 
  and
  {\tt MixColumns}~\cite[Section 5.1.3]{SCARV:FIPS:197}
  operations:
  this is applicable to a column-oriented implementation of AES, whereby
  columns of the state (resp. round key) matrix are packed into $32$-bit
  words.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{mode}
  $
  controls which variant is applied: these variants are exposed via
  dedicated mnemonics st.
  \[
  \begin{array}{l c r@{\;}c@{\;}l@{\;}}
  \VERB[RV]{xc.aesmix.enc}    &\mapsto& \VERB[RV]{mode} &=& 0                          \\
  \VERB[RV]{xc.aesmix.dec}    &\mapsto& \VERB[RV]{mode} &=& 1                          \\
  \end{array}
  \]
  $\VERB[RV]{mode}$ is encoded in the $\VERB[RV]{ca}$ field.
}{
    $t_0                 \ASN                                \XCR[*][\OPER{crs1}]_{ 7 \RANGE  0}  $ \;
    $t_1                 \ASN                                \XCR[*][\OPER{crs1}]_{15 \RANGE  8}  $ \;
    $t_2                 \ASN                                \XCR[*][\OPER{crs2}]_{23 \RANGE 16}  $ \;
    $t_3                 \ASN                                \XCR[*][\OPER{crs2}]_{31 \RANGE 24}  $ \;

  \eIf{$\VERB[RV]{mode} = 0$}{
    $\XCR[*][\OPER{crd0}] \ASN \SCOPE{\ID{AES}}{\ALG{Mix-Column}}     ( t_3 \CONS t_2 \CONS t_1 \CONS t_0 )$ \;
  }{
    $\XCR[*][\OPER{crd0}] \ASN \SCOPE{\ID{AES}}{\ALG{Mix-Column}}^{-1}( t_3 \CONS t_2 \CONS t_1 \CONS t_0 )$ \;
  }
}

% -----------------------------------------------------------------------------

\subsubsection{Class-$3.2$: SHA3}
\label{sec:spec:instruction:3:2}

All SHA3 instructions include a 2-bit immediate {\tt shamt} value, which can
be used to align the result to a byte, halfword, word or double word memory
address boundary. This means the instructions can be used to accelerate all
FIPS standardised sizes of the Keccak function.

Note these instructions source and sink values in the standard RISC-V
General Purpose Registers, rather than the \XCID Registers.

\XCINSTR{xc.sha3.xy}{rd, rs1, rs2, shamt}{
Used to compute indexes into a SHA3 state array.
}{
    $ x \ASN \GPR[*][rs1]_{4 \RANGE 0} $ \;
    $ y \ASN \GPR[*][rs2]_{4 \RANGE 0} $ \;
    $ \GPR[*][crd] \ASN ((x\%5) + 5*(y\%5)) \LSH shamt $ \;
}

\XCINSTR{xc.sha3.x1}{rd, rs1, rs2, shamt}{
Used to compute indexes into a SHA3 state array.
}{
    $ x \ASN \GPR[*][rs1]_{4 \RANGE 0} $ \;
    $ y \ASN \GPR[*][rs2]_{4 \RANGE 0} $ \;
    $ \GPR[*][crd] \ASN (((x+1)\%5) + 5*(y\%5)) \LSH shamt $ \;
}

\XCINSTR{xc.sha3.x2}{rd, rs1, rs2, shamt}{
Used to compute indexes into a SHA3 state array.
}{
    $ x \ASN \GPR[*][rs1]_{4 \RANGE 0} $ \;
    $ y \ASN \GPR[*][rs2]_{4 \RANGE 0} $ \;
    $ \GPR[*][crd] \ASN (((x+2)\%5) + 5*(y\%5)) \LSH shamt $ \;
}

\XCINSTR{xc.sha3.x4}{rd, rs1, rs2, shamt}{
Used to compute indexes into a SHA3 state array.
}{
    $ x \ASN \GPR[*][rs1]_{4 \RANGE 0} $ \;
    $ y \ASN \GPR[*][rs2]_{4 \RANGE 0} $ \;
    $ \GPR[*][crd] \ASN (((x+4)\%5) + 5*(y\%5)) \LSH shamt $ \;
}

\XCINSTR{xc.sha3.yx}{rd, rs1, rs2, shamt}{
Used to compute indexes into a SHA3 state array.
}{
    $ x \ASN \GPR[*][rs1]_{4 \RANGE 0} $ \;
    $ y \ASN \GPR[*][rs2]_{4 \RANGE 0} $ \;
    $ \GPR[*][crd] \ASN (((y)\%5) + 5*((2*x+3*y)\%5)) \LSH shamt $ \;
}

% =============================================================================
