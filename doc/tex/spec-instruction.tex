\subsection{\XCID instructions}
\label{sec:spec:instruction}

% =============================================================================

\subsubsection{Class-$1$:   baseline}
\label{sec:spec:instruction:1}

% -----------------------------------------------------------------------------

\XCINSTR{xc.init}{}{
  Initialise \XCID state, matching post-reset values.
  This instruction is motivated by the requirement to prevent
  1)      logical information leakage,
     and 
  2) side-channel information leakage.
  The former case
  essentially relates to process isolation: \VERB[RV]{xc.init} can be
  used during a context switch, as a way to prevent exposure of \XCID
  state associated with one process to another.
  The latter case
  relates to the proposal of Ge et al.~\cite{SCARV:GeYarHei:18}: they
  argue that a mechanism to reset micro-architectural state is vital,
  because doing so is a requirement for robust prevention of certain
  types of side-channel attack.  \VERB[RV]{xc.init} can be seen as a
  hook against which implementations realise this requirement.

  Keep in mind that the semantics of \VERB[RV]{xc.init} imply a need
  for diversity wrt. their implementation.  Put another way, although
  the architectural effect of \VERB[RV]{xc.init} can be specified in
  a precise way, the micro-architectural effect fundamentally depends 
  on the micro-architecture.  With this in mind, an implementation of
  \XCID {\em must} clearly state said effect, 
  i.e., {\em what} \VERB[RV]{xc.init} does and {\em how} it does so.
}{
  \For{$i = 0$ {\bf upto} $15$}{
    $\XCR[*][{\VERB[RV]{i}}] \ASN 0$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.xcr2gpr}{rd, crs1}{
  Move                                        an $\XCR$ register to a  $\GPR$ register;
  the $\XCR$ register is zero-extended to $\RVXLEN$ bits.
}{ 
  $\GPR[*][{\VERB[RV]{rd}}] \ASN \EXT[\RVXLEN]{0}(\XCR[*][{\VERB[RV]{crs1}}])$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gpr2xcr}{crd, rs1}{
  Move the least-significant $\XCLEN$-bits of a  $\GPR$ register to an $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \INDEX{\GPR[*][{\VERB[RV]{rs1}}]}{31 \RANGE 0}$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.cmov.t}{crd, crs1, crs2}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] \neq 0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.cmov.f}{crd, crs1, crs2}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] =    0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.bu}{crd, h, b, imm11(rs1)}{
  Load a      byte from memory
  into a specific      byte of an $\XCR$ register.
  Beyond this, note that
  1) if
     $\VERB[RV]{h} =    0$ 
     and
     $\VERB[RV]{b} =    0$,
     all other      bytes in the $\XCR$ register are set to zero,
     whereas
  2) if 
     $\VERB[RV]{h} \neq 0$ 
     or 
     $\VERB[RV]{b} \neq 0$,
     no  other      bytes in the $\XCR$ register are modified.
}{
  $addr                                          \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index                                         \ASN ( \VERB[RV]{cc} \CONS \VERB[RV]{cd} ) \XOR 0$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  } \ASN \MEM[*][{addr  }]$ \;
  \If{$index = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.hu}{crd, h,    imm11(rs1)}{
  Load a half-word from memory
  into a specific half-word of an $\XCR$ register.
  Beyond this, note that
  1) if
     $\VERB[RV]{h} =    0$ 
     and
     $\VERB[RV]{b} =    0$,
     all other half-words in the $\XCR$ register are set to zero,
     whereas
  2) if 
     $\VERB[RV]{h} \neq 0$ 
     or 
     $\VERB[RV]{b} \neq 0$,
     no  other half-words in the $\XCR$ register are modified.
  If the effective address $addr$ is not half-word aligned, 
  the memory access {\em must} raise an exception in the same way
  as the base ISA 
  (e.g., per \VERB[RV]{lh}~\cite[Section 2.6]{SCARV:RV:ISA:I:17})
  would.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0                                       \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 0$ \;
  $index_1                                       \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 1$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1} \ASN \MEM[*][{addr+1}]$ \;
  \If{$index_0 = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.w} {crd,        imm11(rs1)}{
  Load a      word from memory 
  into                         an $\XCR$ register.
  If the effective address $addr$ is not      word aligned, 
  the memory access {\em must} raise an exception in the same way
  as the base ISA 
  (e.g., per \VERB[RV]{lw}~\cite[Section 2.6]{SCARV:RV:ISA:I:17})
  would.
}{
  $addr                                          \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0                                       \ASN                                            0$ \;
  $index_1                                       \ASN                                            1$ \;
  $index_2                                       \ASN                                            2$ \;
  $index_3                                       \ASN                                            3$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1} \ASN \MEM[*][{addr+1}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_2} \ASN \MEM[*][{addr+2}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_3} \ASN \MEM[*][{addr+3}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ldr.bu}{crd(b0), rs1, rs2}{
  Load a      byte from memory
  into a specific      byte of an $\XCR$ register;
  Beyond this, note that
  1) if
     $\VERB[RV]{b0} =    0$,
     all other      bytes in the $\XCR$ register are set to zero,
     whereas
  2) if 
     $\VERB[RV]{b0} \neq 0$,
     no  other      bytes in the $\XCR$ register are modified.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $index \ASN \VERB[RV]{b0}$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  } \ASN \MEM[*][{addr  }]$ \;
  \If{$index = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ldr.hu}{crd(b0), rs1, rs2}{
  Load a half-word from memory
  into a specific half-word of an $\XCR$ register;
  Beyond this, note that
  1) if
     $\VERB[RV]{b0} =    0$,
     all other half-words in the $\XCR$ register are set to zero,
     whereas
  2) if 
     $\VERB[RV]{b0} \neq 0$,
     no  other half-words in the $\XCR$ register are modified.
  If the effective address $addr$ is not half-word aligned, 
  the memory access {\em must} raise an exception in the same way
  as the base ISA 
  (e.g., per \VERB[RV]{lw}~\cite[Section 2.6]{SCARV:RV:ISA:I:17})
  would.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $index \ASN \VERB[RV]{b0}$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  } \ASN \MEM[*][{addr  }]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index+1} \ASN \MEM[*][{addr+1}]$ \;
  \If{$index = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ldr.w}{crd, rs1, rs2}{
  Load a      word from memory 
  into                         an $\XCR$ register.
  If the effective address $addr$ is not      word aligned, 
  the memory access {\em must} raise an exception in the same way
  as the base ISA 
  (e.g., per \VERB[RV]{lw}~\cite[Section 2.6]{SCARV:RV:ISA:I:17})
  would.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][{addr+1}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][{addr+2}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][{addr+3}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.b} {rs2, h, b, imm11(rs1)}{
  Store a specific      byte of an $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index           \ASN ( \VERB[RV]{cc} \CONS \VERB[RV]{cd} ) \XOR 0$ \;
  $\MEM[*][addr  ] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  }$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.h} {rs2, h,    imm11(rs1)}{
  Store a specific half-word of an $\XCR$ register into memory.
  If the effective address $addr$ is not      word aligned, 
  the memory access {\em must} raise an exception in the same way
  as the base ISA 
  (e.g., per \VERB[RV]{sh}~\cite[Section 2.6]{SCARV:RV:ISA:I:17})
  would.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0         \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 0 $ \;
  $index_1         \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 1 $ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.w} {rs2,       imm11(rs1)}{
  Store                         an $\XCR$ register into memory.
  If the effective address $addr$ is not      word aligned, 
  the memory access {\em must} raise an exception in the same way
  as the base ISA 
  (e.g., per \VERB[RV]{sw}~\cite[Section 2.6]{SCARV:RV:ISA:I:17})
  would.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0         \ASN                                            0 $ \;
  $index_1         \ASN                                            1 $ \;
  $index_2         \ASN                                            2 $ \;
  $index_3         \ASN                                            3 $ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1}$ \;
  $\MEM[*][addr+2] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_2}$ \;
  $\MEM[*][addr+3] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.str.b}{crd(b0), rs1, rs2}{
  Store a specific      byte of an $\XCR$ register into memory.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $index \ASN \VERB[RV]{b0}$ \;
  $\MEM[*][{addr  }] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.str.h}{crd(b0), rs1, rs2}{
  Store a specific half-word of an $\XCR$ register into memory.
  If the effective address $addr$ is not half-word aligned, 
  the memory access {\em must} raise an exception in the same way
  as the base ISA 
  (e.g., per \VERB[RV]{sh}~\cite[Section 2.6]{SCARV:RV:ISA:I:17})
  would.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $index \ASN \VERB[RV]{b0}$ \;
  $\MEM[*][{addr+0}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index+0}$ \;
  $\MEM[*][{addr+1}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index+1}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.str.w}{crd, rs1, rs2}{
  Store                         an $\XCR$ register into memory.
  If the effective address $addr$ is not      word aligned, 
  the memory access {\em must} raise an exception in the same way
  as the base ISA 
  (e.g., per \VERB[RV]{sw}~\cite[Section 2.6]{SCARV:RV:ISA:I:17})
  would.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $\MEM[*][{addr+0}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][{addr+1}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][{addr+2}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][{addr+3}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% =============================================================================

\subsubsection{Class-$2.1$: randomness}
\label{sec:spec:instruction:2:1}

\XCINSTR{xc.rngtest}{rd1}{
  Inspect the RNG state, applying a suitable ``health check'' on the level 
  of entropy available: the status flag is stored in a $\GPR$ register.
  If, after execution \VERB[RV]{xc.rngseed},
         $\GPR[*][{\VERB[RV]{rd1}}] \neq 0$
  (resp. $\GPR[*][{\VERB[RV]{rd1}}] =    0$),
  then the RNG has 
           sufficient 
  (resp. insufficient)
  entropy; the next output sampled via \VERB[RV]{xc.rngsamp} 
  therefore
         can
  (resp. cannot, or at least should not)
  be used.
}{
  $\GPR[*][{\VERB[RV]{rd1}}] \TEST{\ASN} \RNG$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.rngseed}{crs1}{
  Inject (or seed) $32$-bits of entropy into the RNG, reading from an $\XCR$ register.
}{
  $\RNG \ASN \XCR[*][{\VERB[RV]{crs1}}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.rngsamp}{crd}{
  Sample           $32$-bits of entropy from the RNG, writing to   an $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \RNG$ \;
}

% =============================================================================

\subsubsection{Class-$2.2$: memory}
\label{sec:spec:instruction:2:2}

The semantics of each instruction in this class could be broadly described 
as involving multiple, potentially non-contiguous memory accesses, i.e., a 
sequence of loads and/or stores; each such access relates to an effective
address, computed as the sum of 
a) an explicit             base address 
   plus
b) an explicit or implicit offset.
Imagine $n$ memory accesses should be performed by an instruction, using a 
sequence of effective addresses denoted
\[
addr = \LIST{ addr_0, addr_1, \ldots, addr_{n-1} } .
\]
To ensure consistency, the instruction must adhere to the following rules 
(in addition to \REFSEC{sec:spec:exceptions}) wrt. exceptions:

\begin{itemize}

\item {\em All} effective addresses must be checked for misalignment, and
      an exception raised if necessary, before {\em any} associated memory 
      accesses are performed: either
      a) $\exists~i$ for which the effective address $addr_i$ is misaligned, 
         in which case {\em none} of the memory accesses are performed,
         or
      b) $\forall~i$           the effective address $addr_i$ is    aligned, 
         in which case {\em  all} of the memory accesses are performed.
      The rationale for this rule is to prevent partial execution of the
      instruction, and thus partial update of either architectural state
      or the memory hierarchy.

\item {\em Some} memory accesses have the potential to raise an exception
      that cannot be predicted, even with a priori knowledge of $addr$;
      examples include page or bus faults.  In such cases,
      a) update to 
         architectural state 
         {\em is not} permitted,
         whereas
      b) update to the 
         memory hierarchy
         {\em is}     permitted,
         but should be avoided or minimised if possible.
      For example, the partial execution of a load instruction would not
      lead to the destination register being updated; it could, however,
      lead to the state of any cache memory being updated.

\end{itemize}

% -----------------------------------------------------------------------------

\XCINSTR{xc.scatter.b}{crd, crs2, rs1}{
  Perform a ``scattered'' store of 
  four      bytes 
  from an $\XCR$ register
  into memory;
  for the $i$-th store, a base-offset style effective address is formed 
  from a
                     a  $\GPR$ register (the   base)
  plus
  a      byte within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\MEM[*][addr_0  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_1  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_2  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_3  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.scatter.h}{crd, crs2, rs1}{
  Perform a ``scattered'' store of 
  two  half-words
  from an $\XCR$ register
  into memory;
  for the $i$-th store, a base-offset style effective address is formed 
  from a
                     a  $\GPR$ register (the   base)
  plus
  a half-word within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\MEM[*][addr_0+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_0+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_1+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_1+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gather.b}{crd, crs2, rs1}{
  Perform a  ``gathered''  load of 
  four      bytes 
  from memory 
  into an $\XCR$ register;
  for the $i$-th  load, a base-offset style effective address is formed 
  from a
                     a  $\GPR$ register (the   base)
  plus
  a      byte within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_1  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_2  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_3  ]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gather.h}{crd, crs2, rs1}{
  Perform a  ``gathered''  load of 
  two  half-words
  from memory 
  into an $\XCR$ register;
  for the $i$-th  load, a base-offset style effective address is formed 
  from a
                     a  $\GPR$ register (the   base)
  plus
  a half-word within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_0+1]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_1+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_1+1]$ \;
}

% =============================================================================

\subsubsection{Class-$2.3$: bit-oriented}
\label{sec:spec:instruction:2:3}

\XCINSTR{xc.ld.liu}{crd, imm16}{
  Load an immediate half-word
  into the lower (or least-significant) half-word of an $\XCR$ register, 
  leaving the other half-word in said register unmodified.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.hiu}{crd, imm16}{
  Load an immediate half-word
  into the upper (or  most-significant) half-word of an $\XCR$ register, 
  leaving the other half-word in said register unmodified.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.bop}{crd, crs1, crs2, lut8}{
  Compute each $1$-bit sub-word (i.e.,    bit) of an $\XCLEN$-bit result
  via application of a function
  \[
  f  : \SET{ 0, 1 }^3 \rightarrow \SET{ 0, 1 }
  \]
  encoded as a truth-table via immediate \VERB[RV]{lut8} st.
  \[
  f( i ) = \INDEX{\VERB[RV]{lut8}}{i}
  \]
  for $0 \leq i <  8$;
  the  input to said function is read    from (the               $1$-bit sub-words of) three $\XCR$ registers,
  and 
  the output                  is written to   (the corresponding $1$-bit sub-word  of) an    $\XCR$ register.
  For example, if
  $\VERB[RV]{lut8} = \RADIX{11110000}{2}$
  then
  $f( \RADIX{000}{2} ) = \RADIX{0}{2}$,
  $f( \RADIX{011}{2} ) = \RADIX{0}{2}$,
  $f( \RADIX{100}{2} ) = \RADIX{1}{2}$,
  and
  $f( \RADIX{111}{2} ) = \RADIX{1}{2}$.
  Note that
  \VERB[RV]{xc.bop}
  allows synthesis of a wider set of functionality;
  for example, it can be used to synthesise 
  standard Boolean instructions in the base ISA
  \[
  \begin{array}{l@{\;}c@{\;}l c l@{\;}c@{\;}l}
  \VERB[RV]{lut8} &=& \RADIX{10001000}{2} &\Longrightarrow& f &=& x \AND y \\
  \VERB[RV]{lut8} &=& \RADIX{11101110}{2} &\Longrightarrow& f &=& x \IOR y \\
  \VERB[RV]{lut8} &=& \RADIX{01100110}{2} &\Longrightarrow& f &=& x \XOR y \\
  \end{array}
  \]
  by padding 
  \VERB[RV]{lut8} 
  appropriately.
}{
  $f = \VERB[RV]{imm8}$ \;
  $t \ASN 0$ \;
  \For{$i = 0$ {\bf upto} $31$} {
    $\INDEX  {t}{i} \ASN f( \INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \CONS \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{i} \CONS \INDEX{\XCR[*][{\VERB[RV]{crs2}}]}{i} )$ \;
  }
  $\XCR[*][{\VERB[RV]{crd}}] \ASN t$ \;
}

% ----------------------------------------------------------------------------

\XCINSTR{xc.lut}{crd, crs1, crs2, crs3}{
  Compute each $4$-bit sub-word (i.e., nibble) of an $\XCLEN$-bit result
  via application of a function
  \[
  f  : \SET{ 0, 1 }^4 \rightarrow \SET{ 0, 1 }^4
  \]
  encoded st.
  \[
  f( i ) = \INDEX[4]{\XCR[*][{\VERB[RV]{crs3}}] \CONS \XCR[*][{\VERB[RV]{crs2}}])}{i}
  \]
  for $0 \leq i < 15$;
  the  input to said function is read    from (a                 $4$-bit sub-word of) an     $\XCR$ register,
  and 
  the output                  is written to   (the corresponding $4$-bit sub-word of) an     $\XCR$ register.
  For example, if
  $\XCR[*][{\VERB[RV]{crs3}}] \CONS \XCR[*][{\VERB[RV]{crs2}}] = \RADIX{0123456789ABCDEF}{16}$
  then
  $f( \RADIX{0000}{2} ) = \RADIX{1111}{2}$,
  $f( \RADIX{0001}{2} ) = \RADIX{1110}{2}$,
  $f( \RADIX{1110}{2} ) = \RADIX{0001}{2}$,
  and
  $f( \RADIX{1111}{2} ) = \RADIX{0000}{2}$.
  Note that
  \VERB[RV]{xc.lut}
  allows synthesis of a wider set of functionality;
  for example, it can be used to synthesise 
  the application of a function
  \[
  f' : \SET{ 0, 1 }^2 \rightarrow \SET{ 0, 1 }^2
  \]
  by padding
  $\XCR[*][{\VERB[RV]{crs3}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  appropriately.
}{
  $f = \XCR[*][{\VERB[RV]{crs3}}] \CONS \XCR[*][{\VERB[RV]{crs2}}]$ \;
  $t \ASN 0$ \;
  \For{$i = 0$ {\bf upto}  $3$}{
    $\INDEX[4]{t}{i} \ASN f( \XCR[*][{\VERB[RV]{crs1}}] )$ \;
  }
  $\XCR[*][{\VERB[RV]{crd}}] \ASN t$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ext}{crd, crs1, start, length}{
  Extract a contiguous sequence of bits 
  from               one     $\XCR$ register (at an arbitrary index), 
  and
   insert them
  into (the LSBs of) another $\XCR$ register;
  the extracted bits are zero-extended.
  Note that, wrt. the encoding,
  $\VERB[RV]{cs}$ contains $\VERB[RV]{start}$
  and
  $\VERB[RV]{cl}$ contains $\VERB[RV]{length} - 1$;
  it is required that
  $
  \VERB[RV]{start} + \VERB[RV]{length} \leq \XCLEN .
  $
}{
  $lo \ASN \VERB[RV]{cs}                $ \;
  $hi \ASN \VERB[RV]{cs} + \VERB[RV]{cl}$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{} \ASN \EXT[32]{0}( \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{hi \RANGE lo} )$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ins}{crd, crs1, start, length}{
  Extract a contiguous sequence of bits 
  from (the LSBs of) one     $\XCR$ register, 
  and
   insert them 
  into               another $\XCR$ register (at an arbitrary index);
  the other bits in said register are unmodified.
  Note that, wrt. the encoding,
  $\VERB[RV]{cs}$ contains $\VERB[RV]{start}$
  and
  $\VERB[RV]{cl}$ contains $\VERB[RV]{length} - 1$;
  it is required that
  $
  \VERB[RV]{start} + \VERB[RV]{length} \leq \XCLEN .
  $
}{
  $lo \ASN \VERB[RV]{cs}                $ \;
  $hi \ASN \VERB[RV]{cs} + \VERB[RV]{cl}$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{hi \RANGE lo}$ \ASN \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{\VERB[RV]{cl} \RANGE 0} \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.bmv}{crd, crs1, s, d}{
  Copy bit
  $\VERB[RV]{s}$
  of
  $\XCR[*][{\VERB[RV]{crs1}}]$
  into bit
  $\VERB[RV]{d}$
  of
  $\XCR[*][{\VERB[RV]{crd}}]$,
  leaving the other bits in said register unmodified.
}{
  $s \ASN \VERB[RV]{cs}$ \;
  $d \ASN \VERB[RV]{cl}$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{d} \ASN \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{s}$ \;
}

% ----------------------------------------------------------------------------

\XCINSTR{xc.pbit}{crd, crs1, cs}{
    A generic permutation instruction.
    This instruction implements a 5-layer butterfly network.
    Each bit in each layer in the network can select one of two bits
    in the previous layer: itself, or another based on some function
    of it's position and layer (see $j'$ below).
    Each $\VERB[RV]{xc.pbit}$ instruction can activate upto 5 layers of
    the network.
    Repeated application of the instruction with different masks can
    achieve any 32-bit permutation in 30 instructions or fewer.
}{
    $t1 = \XCR[*][{\VERB[RV]{crd}}]$\;
    $t2 = 0$\;
    \For{$i=0$ {\bf upto} $4$}{
        \If{$\INDEX{\VERB[RV]{cs}}{i}$} {
            \For{$j=0$ {\bf upto} $32$}{
                $j' =  ((j+2^i) \% 2^{i+1})+(j/(2^{i+1}) * 2^{i+1})$ \;
                $ s = \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{j} ? j : j'$\;
                $\INDEX{t2}{j} =  \INDEX{\VERB[RV]{t1}}{s} $ \;
            }
            $t1 = t2$\;
        }
    }
    $\XCR[*][{\VERB[RV]{crd}}] = t1$ \;
}

% ----------------------------------------------------------------------------

\XCINSTR{xc.ipbit}{crd, crs1, cs}{
    A generic inverse permutation instruction.
    Works just like the $\VERB[RV]{xc.pbit}$ instruction, but
    propagates backwards through the buterfly network.
}{
    $t1 = \XCR[*][{\VERB[RV]{crd}}]$\;
    $t2 = 0$\;
    \For{$i=0$ {\bf upto} $4$}{
        \If{$\INDEX{\VERB[RV]{cs}}{i}$} {
            \For{$j=0$ {\bf upto} $32$}{
                $k=4-i$ \;
                $j' =  ((j+2^k) \% 2^{k+1})+(j/(2^{k+1}) * 2^{k+1})$ \;
                $ s = \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{j} ? j : j'$\;
                $\INDEX{t2}{j} =  \INDEX{\VERB[RV]{t1}}{s} $ \;
            }
            $t1 = t2$\;
        }
    }
    $\XCR[*][{\VERB[RV]{crd}}] = t1$ \;
}

% ----------------------------------------------------------------------------

\XCINSTR{xc.pbyte}{crd, crs1, b0, b1, b2, b3}{
    A byte level permutation instruction. Allows any byte in a source
    word to be placed in any byte of a destination word.
    This instruction can be used for fast endianness manipulation, and
    a faster way to implement some permutation layers of the
    $\VERB[RV]{xc.pbit}$ and 
    $\VERB[RV]{xc.ipbit}$
    instructions.
}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crs1}}]}{b0}$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crs1}}]}{b1}$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crs1}}]}{b2}$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crs1}}]}{b3}$ \;
}

% =============================================================================

\subsubsection{Class-$2.4$: packed}
\label{sec:spec:instruction:2:4}

Each instruction in this class computes a packed operation: for an operator
$\odot$, register or immediate variants essentially compute

\begin{enumerate}
\item $\INDEX[w]{r}{i} = \INDEX[w]{x}{i} \OP[w][u]{\odot} \INDEX[w]{y}{i}$,
      for $r$, $x$, and $y$ in $\XCR$ registers.
      and
\item $\INDEX[w]{r}{i} = \INDEX[w]{x}{i} \OP[w][u]{\odot}           y    $,
      for $r$       and $x$ in $\XCR$ registers, and an immediate $y$,
\end{enumerate}

\noindent
and for each 
$
0 \leq i < \VERB[RV]{n} ,
$ 
where the field count
$
\VERB[RV]{n} \in \SET{ 1, 2, 4, 8, 16 }
$ 
specified in the instruction encoding implies a field width of 
$
w = \XCLEN / \VERB[RV]{n} .
$
As such, said encoding yields the following cases
\[
\begin{array}{ccrcc@{\;}c@{\;}rc@{\;}c@{\;}r}
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{000}{2} &\mapsto& \VERB[RV]{n} &=&  1 & w &=& 32     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{001}{2} &\mapsto& \VERB[RV]{n} &=&  2 & w &=& 16     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{010}{2} &\mapsto& \VERB[RV]{n} &=&  4 & w &=&  8     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{011}{2} &\mapsto& \VERB[RV]{n} &=&  8 & w &=&  4     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{100}{2} &\mapsto& \VERB[RV]{n} &=&  1 & w &=& 32     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{101}{2} &\mapsto& \VERB[RV]{n} &=& 16 & w &=&  2     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{110}{2} &\mapsto& \multicolumn{6}{c}{\mbox{invalid}} \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{111}{2} &\mapsto& \multicolumn{6}{c}{\mbox{invalid}} \\
\end{array}
\]
where cases marked invalid are reserved.  Note that the encoding 
$
\RADIX{100}{2}
$
is valid only for the instructions
\VERB[RV]{xc.psll.i},
\VERB[RV]{xc.psrl.i} and
\VERB[RV]{xc.prot.i}.
In this case, the \VERB[RV]{ca} bit is used to encode the most significant
bit of the shift/rotate amount; for all other instructions, the encoding
is considered invalid.

% -----------------------------------------------------------------------------

\XCINSTR{xc.padd}{pw, crd, crs1, crs2}{
  Compute a   register-based packed addition, 
  implying $\odot = +$.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{+}      \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psub}{pw, crd, crs1, crs2}{
  Compute a   register-based packed subtraction, 
  implying $\odot = -$.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{-}      \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pmul.l}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication,
  implying $\odot = \times$;
  this instruction captures the  ``low'' half, or $w$ LSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pmul.h},   which captures the ``high'' half, or $w$ MSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{ \times} \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{        w - 1 \RANGE 0}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pmul.h}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication,
  implying $\odot = \times$;
  this instruction captures the ``high'' half, or $w$ MSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pmul.l},   which captures the  ``low'' half, or $w$ LSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{ \times} \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{2 \cdot w - 1 \RANGE w}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pclmul.l}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication in $\B{F}_2[\IND{x}]$ (or ``carry-less'' multiplication),
  implying $\odot = \otimes$;
  this instruction captures the  ``low'' half, or $w$ LSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pclmul.h}, which captures the ``high'' half, or $w$ MSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\otimes} \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{        w - 1 \RANGE 0}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pclmul.h}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication in $\B{F}_2[\IND{x}]$ (or ``carry-less'' multiplication),
  implying $\odot = \otimes$;
  this instruction captures the ``high'' half, or $w$ MSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pclmul.l}, which captures the  ``low'' half, or $w$ LSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\otimes} \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{2 \cdot w - 1 \RANGE w}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psll}{pw, crd, crs1, crs2}{
  Compute a   register-based packed left-shift,
  implying $\odot = \LSH$.
  Keep in mind that
  any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LSH}             \XCR[*][{\VERB[RV]{crs2}}]    $ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psll.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed left-shift,
  implying $\odot = \LSH$.
  Note that, wrt. the encoding,
  the distance is given by
  \[
  \VERB[RV]{shamt} = \left\{\begin{array}{rl}
                            \VERB[RV]{ca} \CONS \VERB[RV]{cshamt} & \mbox{~~if $w =    32$} \\
                            0             \CONS \VERB[RV]{cshamt} & \mbox{~~if $w \neq 32$} \\
                            \end{array}
                     \right.
  \]
  i.e., 
  $
  \VERB[RV]{ca}
  $
  is used to encode the MSB iff. $w = 32$.
  Keep in mind that
  any out-of-range distance
  $
  \VERB[RV]{shamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 
  $
  either way.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \eIf{$w = 32$}{
    $\VERB[RV]{shamt} = \VERB[RV]{ca} \CONS \VERB[RV]{cshamt}$\;
  }{
    $\VERB[RV]{shamt} = 0             \CONS \VERB[RV]{cshamt}$\;
  }
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LSH}   \VERB[RV]{shamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psrl}{pw, crd, crs1, crs2}{
  Compute a   register-based packed right-shift,
  implying $\odot = \RSH$.
  Keep in mind that
  any out-of-range distance
  $
  \VERB[RV]{shamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RSH}             \XCR[*][{\VERB[RV]{crs2}}]    $ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psrl.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed left-shift,
  implying $\odot = \RSH$.
  Note that, wrt. the encoding,
  the distance is given by
  \[
  \VERB[RV]{shamt} = \left\{\begin{array}{rl}
                            \VERB[RV]{ca} \CONS \VERB[RV]{cshamt} & \mbox{~~if $w =    32$} \\
                            0             \CONS \VERB[RV]{cshamt} & \mbox{~~if $w \neq 32$} \\
                            \end{array}
                     \right.
  \]
  i.e., 
  $
  \VERB[RV]{ca}
  $
  is used to encode the MSB iff. $w = 32$.
  Keep in mind that
  any out-of-range distance
  $
  \VERB[RV]{shamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 
  $
  either way.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \eIf{$w = 32$}{
    $\VERB[RV]{shamt} = \VERB[RV]{ca} \CONS \VERB[RV]{cshamt}$\;
  }{
    $\VERB[RV]{shamt} = 0             \CONS \VERB[RV]{cshamt}$\;
  }
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RSH}   \VERB[RV]{shamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.prot}{pw, crd, crs1, crs2}{
  Compute a   register-based packed right-rotate,
  implying $\odot = \RRT$.
  Keep in mind that
  the effective distance will be
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \pmod{w} .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RRT}             \XCR[*][{\VERB[RV]{crs2}}]    $ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.prot.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed right-rotate,
  implying $\odot = \RRT$.
  Note that, wrt. the encoding,
  the distance is given by
  \[
  \VERB[RV]{rtamt} = \left\{\begin{array}{rl}
                            \VERB[RV]{ca} \CONS \VERB[RV]{cshamt} & \mbox{~~if $w =    32$} \\
                            0             \CONS \VERB[RV]{cshamt} & \mbox{~~if $w \neq 32$} \\
                            \end{array}
                     \right.
  \]
  i.e., 
  $
  \VERB[RV]{ca}
  $
  is used to encode the MSB iff. $w = 32$.
  Keep in mind that
  the effective distance will be
  $
  \VERB[RV]{rtamt} \pmod{w} 
  $
  either way.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \eIf{$w = 32$}{
    $\VERB[RV]{rtamt} = \VERB[RV]{ca} \CONS \VERB[RV]{cshamt}$\;
  }{
    $\VERB[RV]{rtamt} = 0             \CONS \VERB[RV]{cshamt}$\;
  }
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RRT}   \VERB[RV]{rtamt}$ \;
  }
}

% =============================================================================

\subsubsection{Class-$2.5$: multi-precision}
\label{sec:spec:instruction:2:5}

Instructions in this class use upto
$4$ source      $\XCR$ registers
and
$2$ destination $\XCR$ registers,
which demands some compromises wrt. the encoding used.
In short, a compressed specification of the destination $\XCR$ registers is
used, whereby a single encoded \VERB[RV]{crdm} field implies (or maps to) a 
pair 
$
\TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} }
$
of register addresses st.
a) $\VERB[RV]{crd2} = \VERB[RV]{crd1} + 1$
   (the contiguous'ness rule),
   and
b) $\VERB[RV]{crd2} = 1 \pmod{2}$
   and 
   $\VERB[RV]{crd1} = 0 \pmod{2}$
   (the  odd-even'ness rule).
Concretely then, this means
\[
\begin{array}{l@{\;}c@{\;}r c c@{\;}l@{\;}c@{\;}r@{\;}c@{\;}l@{\;}c@{\;}r@{\;}c}
\VERB[RV]{crdm} &=& \RADIX{000}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  1 &,& \VERB[RV]{crd1} &=&  0 & ) \\
\VERB[RV]{crdm} &=& \RADIX{001}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  3 &,& \VERB[RV]{crd1} &=&  2 & ) \\
\VERB[RV]{crdm} &=& \RADIX{010}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  5 &,& \VERB[RV]{crd1} &=&  4 & ) \\
\VERB[RV]{crdm} &=& \RADIX{011}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  7 &,& \VERB[RV]{crd1} &=&  6 & ) \\
\VERB[RV]{crdm} &=& \RADIX{100}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  9 &,& \VERB[RV]{crd1} &=&  8 & ) \\
\VERB[RV]{crdm} &=& \RADIX{101}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 11 &,& \VERB[RV]{crd1} &=& 10 & ) \\
\VERB[RV]{crdm} &=& \RADIX{110}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 13 &,& \VERB[RV]{crd1} &=& 12 & ) \\
\VERB[RV]{crdm} &=& \RADIX{111}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 15 &,& \VERB[RV]{crd1} &=& 14 & ) \\
\end{array}
\]
i.e.,
\[
\VERB[RV]{crdm} = x ~~\mapsto~~ \TUPLE{ \VERB[RV]{crd2} = x \CONS 1 , \VERB[RV]{crd1} = x \CONS 0 } ,
\]
noting
$\TUPLE{ 1, 0 }$ and $\TUPLE{ 3, 2 }$ are deemed valid pairs,
$\TUPLE{ 3, 0 }$ is invalid because it violates the contiguous'ness rule,
$\TUPLE{ 2, 3 }$ is invalid because it violates the contiguous'ness rule,
and
$\TUPLE{ 2, 1 }$ is invalid because it violates the  odd-even'ness rule.

% -----------------------------------------------------------------------------

\XCINSTR{xc.madd.2}{(crd2, crd1), crs1, crs2      }{
  Compute a   register-based multi-precision (or ``long'') addition:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the addends,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the sum,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the carry-out,
  meaning the instruction acts as a word-oriented analogue of a half-adder.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.madd.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') addition:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the addends,
  $\XCR[*][{\VERB[RV]{crs3}}]$ as the carry-in,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the sum,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the carry-out,
  meaning the instruction acts as a word-oriented analogue of a full-adder.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{+} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msub.2}{(crd2, crd1), crs1, crs2      }{
  Compute a   register-based multi-precision (or ``long'') subtraction:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$ as the    minuend,
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the subtrahend,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the difference,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the borrow-out,
  meaning the instruction acts as a word-oriented analogue of a half-subtractor.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msub.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') subtraction:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$ as the    minuend,
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the subtrahend,
  $\XCR[*][{\VERB[RV]{crs3}}]$ as the borrow-in,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the difference,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the borrow-out,
  meaning the instruction acts as a word-oriented analogue of a full-subtractor.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{-} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.macc.1}{(crd2, crd1), crs1      }{
  Compute a   register-based multi-precision (or ``long'') accumulation,
  with the
  $\XCLEN$-bit addend
  $\XCR[*][{\VERB[RV]{crs1}}]$
  accumulated into a $( 2 \cdot \XCLEN )$-bit value formed by concatenating
  $\XCR[*][{\VERB[RV]{crd1}}]$
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.macc.2}{(crd2, crd1), crs1, crs2}{
  Compute a   register-based multi-precision (or ``long'') accumulation,
  with the
  $\XCLEN$-bit addends
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  accumulated into a $( 2 \cdot \XCLEN )$-bit value formed by concatenating
  $\XCR[*][{\VERB[RV]{crd1}}]$
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}] 
                                                                                                   \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs2}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mmul.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') multiply-accumulate:
  the $\XCLEN$-bit multiplicands
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  are first used to form a $( 2 \cdot \XCLEN )$-bit product captured by
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs),
  into which the $\XCLEN$-bit addend
  $\XCR[*][{\VERB[RV]{crs3}}]$
  is accumulated.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{ \times} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{ +}      \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mclmul.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') multiply-accumulate in $\B{F}_2[\IND{x}]$:
  the $\XCLEN$-bit multiplicands
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  are first used to form a $( 2 \cdot \XCLEN )$-bit product captured by
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs),
  into which the $\XCLEN$-bit addend
  $\XCR[*][{\VERB[RV]{crs3}}]$
  is accumulated.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\otimes} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{\oplus}  \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msll}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'')  left-shift:
  a $( 2 \cdot \XCLEN )$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then  left-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } ,
  $
  and that any out-of-range distance
  $
  \XCR[*][{\VERB[RV]{crs3}}] \geq 2 \cdot \XCLEN
  $
  will yield
  $
  \XCR[*][{\VERB[RV]{crd1}}] = \XCR[*][{\VERB[RV]{crd2}}] = 0 .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\LSH} \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msll.i}{(crd2, crd1), crs1, crs2, shamt}{
  Compute an immediate-based multi-precision (or ``long'')  left-shift:
  a $( 2 \cdot \XCLEN )$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then  left-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\LSH} \VERB[RV]{cmshamt}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msrl}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') right-shift:
  a $( 2 \cdot \XCLEN )$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then right-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } ,
  $
  and that any out-of-range distance
  and that any out-of-range distance
  $
  \XCR[*][{\VERB[RV]{crs3}}] \geq 2 \cdot \XCLEN
  $
  will yield
  $
  \XCR[*][{\VERB[RV]{crd1}}] = \XCR[*][{\VERB[RV]{crd2}}] = 0 .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\RSH} \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msrl.i}{(crd2, crd1), crs1, crs2, shamt}{
  Compute an immediate-based multi-precision (or ``long'') right-shift:
  a $( 2 \cdot \XCLEN )$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then right-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\RSH} \VERB[RV]{cmshamt}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mequ}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
  equality 
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN \EXT[\RVXLEN]{0}(            t_0 \AND \INDEX{\GPR[*][{\VERB[RV]{rs1}}]}{0}   )$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mlte}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
     less-than
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $t_1 \ASN \XCR[*][{\VERB[RV]{crs2}}] < \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN \EXT[\RVXLEN]{0}( t_1 \IOR ( t_0 \AND \INDEX{\GPR[*][{\VERB[RV]{rs1}}]}{0} ) )$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mgte}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
  greater-than
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $t_1 \ASN \XCR[*][{\VERB[RV]{crs2}}] > \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN \EXT[\RVXLEN]{0}( t_1 \IOR ( t_0 \AND \INDEX{\GPR[*][{\VERB[RV]{rs1}}]}{0} ) )$ \;
}

% -----------------------------------------------------------------------------

\subsubsection{Class-$3.1$: AES}
\label{sec:spec:instruction:3:1}

\XCINSTR{xc.aessub}{.\[enc,dec\]\[rot\] crd, crs1, crs2}{
  Per~\cite[Figures 5]{SCARV:TilGro:06}, 
  apply a (carefully structured) form of the AES 
  {\tt SubBytes}~\cite[Section 5.1.1]{SCARV:FIPS:197}
  operation:
  this is applicable to a column-oriented implementation of AES, where
  state (resp. round key) matrix columns are packed into $\XCLEN$-bit
  words.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{mode}
  $
  and
  $
  \VERB[RV]{rot}
  $
  control  which variant is applied: these variants are exposed via
  dedicated mnemonics st.
  \[
  \begin{array}{l c r@{\;}c@{\;}l @{\;}c@{\;} r@{\;}c@{\;}l}
  \VERB[RV]{xc.aessub.enc}    &\mapsto& \VERB[RV]{mode} &=& 0 &,& \VERB[RV]{rot} &=& 0 \\
  \VERB[RV]{xc.aessub.encrot} &\mapsto& \VERB[RV]{mode} &=& 0 &,& \VERB[RV]{rot} &=& 1 \\
  \VERB[RV]{xc.aessub.dec}    &\mapsto& \VERB[RV]{mode} &=& 1 &,& \VERB[RV]{rot} &=& 0 \\
  \VERB[RV]{xc.aessub.decrot} &\mapsto& \VERB[RV]{mode} &=& 1 &,& \VERB[RV]{rot} &=& 1 \\
  \end{array}
  \]
  $\VERB[RV]{mode}$ is encoded in the $\VERB[RV]{ca}$ field and
  $\VERB[RV]{rot}$  is encoded in the $\VERB[RV]{cb}$ field.
}{
  \eIf{$\VERB[RV]{mode} = 0$}{
    $t_0                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][{\VERB[RV]{crs1}}]_{ 7 \RANGE  0} )$ \;
    $t_1                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][{\VERB[RV]{crs2}}]_{15 \RANGE  8} )$ \;
    $t_2                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][{\VERB[RV]{crs1}}]_{23 \RANGE 16} )$ \;
    $t_3                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][{\VERB[RV]{crs2}}]_{31 \RANGE 24} )$ \;
  }{
    $t_0                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][{\VERB[RV]{crs1}}]_{ 7 \RANGE  0} )$ \;
    $t_1                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][{\VERB[RV]{crs2}}]_{15 \RANGE  8} )$ \;
    $t_2                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][{\VERB[RV]{crs1}}]_{23 \RANGE 16} )$ \;
    $t_3                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][{\VERB[RV]{crs2}}]_{31 \RANGE 24} )$ \;
  }
  
  \eIf{$\VERB[RV]{rot}  = 0$}{
    $\XCR[*][{\VERB[RV]{crd0}}] \ASN                                          t_3 \CONS t_2 \CONS t_1 \CONS t_0 $ \;
  }{
    $\XCR[*][{\VERB[RV]{crd0}}] \ASN                                          t_2 \CONS t_1 \CONS t_0 \CONS t_3 $ \;
  }
}

\XCINSTR{xc.aesmix}{mode,      crd, crs1, crs2}{
  Per~\cite[Figures 5]{SCARV:TilGro:06}, 
  apply a (carefully structured) form of the AES 
  {\tt ShiftRows}~\cite[Section 5.1.2]{SCARV:FIPS:197} 
  and
  {\tt MixColumns}~\cite[Section 5.1.3]{SCARV:FIPS:197}
  operations:
  this is applicable to a column-oriented implementation of AES, where
  state (resp. round key) matrix columns are packed into $\XCLEN$-bit
  words.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{mode}
  $
  controls which variant is applied: these variants are exposed via
  dedicated mnemonics st.
  \[
  \begin{array}{l c r@{\;}c@{\;}l@{\;}}
  \VERB[RV]{xc.aesmix.enc}    &\mapsto& \VERB[RV]{mode} &=& 0                          \\
  \VERB[RV]{xc.aesmix.dec}    &\mapsto& \VERB[RV]{mode} &=& 1                          \\
  \end{array}
  \]
  $\VERB[RV]{mode}$ is encoded in the $\VERB[RV]{ca}$ field.
}{
    $t_0                        \ASN                                     \XCR[*][{\VERB[RV]{crs1}}]_{ 7 \RANGE  0}  $ \;
    $t_1                        \ASN                                     \XCR[*][{\VERB[RV]{crs1}}]_{15 \RANGE  8}  $ \;
    $t_2                        \ASN                                     \XCR[*][{\VERB[RV]{crs2}}]_{23 \RANGE 16}  $ \;
    $t_3                        \ASN                                     \XCR[*][{\VERB[RV]{crs2}}]_{31 \RANGE 24}  $ \;

  \eIf{$\VERB[RV]{mode} = 0$}{
    $\XCR[*][{\VERB[RV]{crd0}}] \ASN \SCOPE{\ID{AES}}{\ALG{Mix-Column}}     ( t_3 \CONS t_2 \CONS t_1 \CONS t_0 )$ \;
  }{
    $\XCR[*][{\VERB[RV]{crd0}}] \ASN \SCOPE{\ID{AES}}{\ALG{Mix-Column}}^{-1}( t_3 \CONS t_2 \CONS t_1 \CONS t_0 )$ \;
  }
}

% -----------------------------------------------------------------------------

\subsubsection{Class-$3.2$: SHA3}
\label{sec:spec:instruction:3:2}

Each instruction in this class computes an index into the SHA3 state array:
they provide domain-specific support for address generation within the step
mappings~\cite[Section 3.2]{SCARV:FIPS:202} (i.e., $\Omega$, $\rho$, $\pi$, 
$\chi$, and $\iota$) that constitute each round.  Note that

\begin{itemize}
\item the $2$-bit immediate \VERB[RV]{shamt} can be used align the index 
      to a byte, half-word, word, or double-word boundary 
      (and thereby support all SHA3 parameterisations), 
      and
\item the instructions use $\GPR$ rather than $\XCR$: this is explained by
      their focus on addressing, vs. computation per se.
\end{itemize}

\XCINSTR{xc.sha3.xy}{rd, rs1, rs2, shamt}{
  Compute an index into the SHA3 state array.
}{
  $x                        \ASN \GPR[*][{\VERB[RV]{rs1}}]_{4 \RANGE 0}$ \;
  $y                        \ASN \GPR[*][{\VERB[RV]{rs2}}]_{4 \RANGE 0}$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( (   x       \bmod 5 ) + 5 \cdot (                       y   \bmod 5 ) ) \LSH \VERB[RV]{shamt}$ \;
}

\XCINSTR{xc.sha3.x1}{rd, rs1, rs2, shamt}{
  Compute an index into the SHA3 state array.
}{
  $x                        \ASN \GPR[*][{\VERB[RV]{rs1}}]_{4 \RANGE 0}$ \;
  $y                        \ASN \GPR[*][{\VERB[RV]{rs2}}]_{4 \RANGE 0}$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( ( ( x + 1 ) \bmod 5 ) + 5 \cdot (                       y   \bmod 5 ) ) \LSH \VERB[RV]{shamt}$ \;
}

\XCINSTR{xc.sha3.x2}{rd, rs1, rs2, shamt}{
  Compute an index into the SHA3 state array.
}{
  $x                        \ASN \GPR[*][{\VERB[RV]{rs1}}]_{4 \RANGE 0}$ \;
  $y                        \ASN \GPR[*][{\VERB[RV]{rs2}}]_{4 \RANGE 0}$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( ( ( x + 2 ) \bmod 5 ) + 5 \cdot (                       y   \bmod 5 ) ) \LSH \VERB[RV]{shamt}$ \;
}

\XCINSTR{xc.sha3.x4}{rd, rs1, rs2, shamt}{
  Compute an index into the SHA3 state array.
}{
  $x                        \ASN \GPR[*][{\VERB[RV]{rs1}}]_{4 \RANGE 0}$ \;
  $y                        \ASN \GPR[*][{\VERB[RV]{rs2}}]_{4 \RANGE 0}$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( ( ( x + 4 ) \bmod 5 ) + 5 \cdot (                       y   \bmod 5 ) ) \LSH \VERB[RV]{shamt}$ \;
}

\XCINSTR{xc.sha3.yx}{rd, rs1, rs2, shamt}{
  Compute an index into the SHA3 state array.
}{
  $x                        \ASN \GPR[*][{\VERB[RV]{rs1}}]_{4 \RANGE 0}$ \;
  $y                        \ASN \GPR[*][{\VERB[RV]{rs2}}]_{4 \RANGE 0}$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( (   y       \bmod 5 ) + 5 \cdot ( ( 2 \cdot x + 3 \cdot y ) \bmod 5 ) ) \LSH \VERB[RV]{shamt}$ \;
}

% =============================================================================
