\subsection{\XCID instructions}
\label{sec:spec:instruction}

% =============================================================================

\subsubsection{Class-$1$:   baseline}
\label{sec:spec:instruction:1}

% -----------------------------------------------------------------------------

\XCINSTR{xc.xcr2gpr}{rd, crs1}{
  Move an $\XCR$ register to a $\GPR$ register.
}{ 
  $\GPR[*][{\VERB[RV]{rd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gpr2xcr}{crd, rs1}{
  Move a $\GPR$ register to an $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \GPR[*][{\VERB[RV]{rs1}}]$\;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.cmov.t}{crd, crs1, crs2}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] \neq 0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.cmov.f}{crd, crs1, crs2}{
  Conditionally move one $\XCR$ register to another.
}{
  \If{$\XCR[*][{\VERB[RV]{crs2}}] =    0$}{
    $\XCR[*][{\VERB[RV]{crd}}] \ASN \XCR[*][{\VERB[RV]{crs1}}]$\;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.bu}{crd, h, b, imm11(rs1)}{
  Load a      byte from memory
  into a specific      byte of an $\XCR$ register.
  If \VERB[RV]{h} or \VERB[RV]{b} are non-zero,
  the other bytes in the destination register are left un-modified.
  If \VERB[RV]{h} and \VERB[RV]{b} are zero,
  the least-significant byte of the destination register
  is set to the loaded byte, and all other bytes in the
  destination register are cleared.
}{
  $addr                                          \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index                                         \ASN ( \VERB[RV]{cc} \CONS \VERB[RV]{cd} ) \XOR 0$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  } \ASN \MEM[*][{addr  }]$ \;
  \If{$index = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.hu}{crd, h,    imm11(rs1)}{
  Load a half-word from memory
  into a specific half-word of an $\XCR$ register,
  If \VERB[RV]{h} is non-zero,
  the low half-word of the destination register is left un-modified.
  If \VERB[RV]{h} is zero,
  the least-significant half-word of the destination register
  is set to the loaded half-word, and all other half-words in the
  destination register are cleared.
}{
  $addr                                                                    \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0                                       \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 0$ \;
  $index_1                                       \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 1$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1} \ASN \MEM[*][{addr+1}]$ \;
  \If{$index_0 = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.w} {crd,        imm11(rs1)}{
  Load a      word from memory 
  into                         an $\XCR$ register.
}{
  $addr                                          \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0                                       \ASN                                            0$ \;
  $index_1                                       \ASN                                            1$ \;
  $index_2                                       \ASN                                            2$ \;
  $index_3                                       \ASN                                            3$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1} \ASN \MEM[*][{addr+1}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_2} \ASN \MEM[*][{addr+2}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_3} \ASN \MEM[*][{addr+3}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.b} {rs2, h, b, imm11(rs1)}{
  Store a specific      byte of an $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index           \ASN ( \VERB[RV]{cc} \CONS \VERB[RV]{cd} ) \XOR 0$ \;
  $\MEM[*][addr  ] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  }$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.h} {rs2, h,    imm11(rs1)}{
  Store a specific half-word of an $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0         \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 0$ \;
  $index_1         \ASN ( \VERB[RV]{cc} \CONS             0 ) \XOR 1$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.st.w} {rs2,       imm11(rs1)}{
  Store                         an $\XCR$ register into memory.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm11} = \VERB[RV]{imm11hi} \CONS \VERB[RV]{imm11lo} .
  $
}{
  $addr            \ASN \GPR[*][{\VERB[RV]{rs1}}] + \EXT[32]{\pm}( \VERB[RV]{imm11} )$ \;
  $index_0         \ASN                                            0$ \;
  $index_1         \ASN                                            1$ \;
  $index_2         \ASN                                            2$ \;
  $index_3         \ASN                                            3$ \;
  $\MEM[*][addr+0] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_0}$ \;
  $\MEM[*][addr+1] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_1}$ \;
  $\MEM[*][addr+2] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_2}$ \;
  $\MEM[*][addr+3] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index_3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ldr.bu}{crd(b0), rs1, rs2}{
Load a byte from memory into a particular byte of an $\XCR$ register.
The memory address is computed by adding the values in
$\GPR[*][{\VERB[RV]{rs1}}]$
and
$\GPR[*][{\VERB[RV]{rs2}}]$.
\VERB[RV]{b0} refers to which byte of the destination register to modify.
If \VERB[RV]{b0} is zero, the zero-extended byte value is written to
$\XCR[*][{\VERB[RV]{crd}}]$.
If \VERB[RV]{b0} is non-zero, then only bytes
\VERB[RV]{b0} 
and
$\VERB[RV]{b0}+1$
of the destination register is modified.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $index \ASN \VERB[RV]{b0}$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  } \ASN \MEM[*][{addr  }]$ \;
  \If{$index = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ldr.hu}{crd(b0), rs1, rs2}{
Load a halfword from memory into an $\XCR$ register.
The memory address is computed by adding the values in
$\GPR[*][{\VERB[RV]{rs1}}]$
and
$\GPR[*][{\VERB[RV]{rs2}}]$.
If the resulting address is not halfword aligned, implementations must raise
exceptions in the same way as the base RISC-V {\tt rv32i} \VERB[RV]{lhu} instruction does.
\VERB[RV]{b0} refers to the first byte of the destination register to modify.
It must be either $0$ or $2$, denoting the lower or upper halfword respectivley.
If \VERB[RV]{b0} is zero, the zero-extended halfword value is written to
$\XCR[*][{\VERB[RV]{crd}}]$.
If \VERB[RV]{b0} is non-zero, then only the \VERB[RV]{b0}'th halfword of the
destination register is modified.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $index \ASN \VERB[RV]{b0}$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index  } \ASN \MEM[*][{addr  }]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index+1} \ASN \MEM[*][{addr+1}]$ \;
  \If{$index = 0$}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN 0$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN 0$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ldr.w}{crd, rs1, rs2}{
Load a word from memory into an $\XCR$ register.
The memory address is computed by adding the values in
$\GPR[*][{\VERB[RV]{rs1}}]$
and
$\GPR[*][{\VERB[RV]{rs2}}]$.
If the resulting address is not word aligned, implementations must raise
exceptions in the same way as the base RISC-V {\tt rv32i} \VERB[RV]{lw} instruction does.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][{addr+0}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][{addr+1}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][{addr+2}]$ \;
  $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][{addr+3}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.str.b}{crd(b0), rs1, rs2}{
Store a byte to memory from an $\XCR$ register.
The memory address is computed by adding the values in
$\GPR[*][{\VERB[RV]{rs1}}]$
and
$\GPR[*][{\VERB[RV]{rs2}}]$.
\VERB[RV]{b0} refers to which byte of the source $\XCR[*][{\VERB[RV]{crd}}]$
register to write to memory.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $index \ASN \VERB[RV]{b0}$ \;
  $\MEM[*][{addr  }] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.str.h}{crd(b0), rs1, rs2}{
Store a halfword to memory from an $\XCR$ register.
The memory address is computed by adding the values in
$\GPR[*][{\VERB[RV]{rs1}}]$
and
$\GPR[*][{\VERB[RV]{rs2}}]$.
If the resulting address is not halfword aligned, implementations must raise
exceptions in the same way as the base RISC-V {\tt rv32i} \VERB[RV]{sh} instruction does.
\VERB[RV]{b0} must be either $0$ or $2$, and refers to the first byte of the source
$\XCR[*][{\VERB[RV]{crd}}]$ register to write to memory.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $index \ASN \VERB[RV]{b0}$ \;
  $\MEM[*][{addr+0}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index+0}$ \;
  $\MEM[*][{addr+1}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{index+1}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.str.w}{crd, rs1, rs2}{
Store a word to memory from an $\XCR$ register.
The memory address is computed by adding the values in
$\GPR[*][{\VERB[RV]{rs1}}]$
and
$\GPR[*][{\VERB[RV]{rs2}}]$.
If the resulting address is not word aligned, implementations must raise
exceptions in the same way as the base RISC-V {\tt rv32i} \VERB[RV]{sw} instruction does.
}{
  $addr  \ASN \GPR[*][{\VERB[RV]{rs1}}] + \GPR[*][{\VERB[RV]{rs2}}]$ \;
  $\MEM[*][{addr+0}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][{addr+1}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][{addr+2}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][{addr+3}] \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.init}{}{
Initialise all XCrypto architectural state to zero.
This instruction is designed to be used during a context switch to prevent
a) logical leakage and 
b) side-channel leakage.
Once any state is saved, this instruction is executed to efficiently set all
XCrypto registers to an initial value.
An implementation may use this instruction to implement any micro-architectural
enforcement of process non-interference.
This might include flushing any time-multiplexed state, or clearing intermediate
value / pipeline registers to prevent side channel leakage.

The aim of this instruction is also to allow implementers to give software an
explicit mechanism to clear any state which is not otherwise architecturally
visible\cite{SCARV:GeYarHei:18}.
This makes the exact implementation of the instruction very device dependent,
even if the architectural effects are limited and explicitly defined.
Any implementation which uses \VERB[RV]{xc.init} to clear micro-architectural
state must document exactly what it does, and {\em how} it does it.
For example, simply setting an intermediate register value to zero will
potentially leak it's hamming weight in a power or EM side channel.
}{
    \For{$i=0$ {\bf upto} $15$}{
        $\XCR[*][{\VERB[RV]{i}}] \ASN 0$
    }
}

% =============================================================================

\subsubsection{Class-$2.1$: randomness}
\label{sec:spec:instruction:2:1}

\XCINSTR{xc.rngtest}{rd1}{
  Inspect the RNG state, applying a suitable ``health check'' on the level 
  of entropy available: the status flag is stored in a $\GPR$ register.
  If, after execution \VERB[RV]{xc.rngseed},
         $\GPR[*][{\VERB[RV]{rd1}}] \neq 0$
  (resp. $\GPR[*][{\VERB[RV]{rd1}}] =    0$),
  then the RNG has 
           sufficient 
  (resp. insufficient)
  entropy; the next output sampled via \VERB[RV]{xc.rngsamp} 
  therefore
         can
  (resp. cannot, or at least should not)
  be used.
}{
  $\GPR[*][{\VERB[RV]{rd1}}] \TEST{\ASN} \RNG$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.rngseed}{crs1}{
  Inject (or seed) $32$-bits of entropy into the RNG, reading from an $\XCR$ register.
}{
  $\RNG \ASN \XCR[*][{\VERB[RV]{crs1}}]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.rngsamp}{crd}{
  Sample           $32$-bits of entropy from the RNG, writing to   an $\XCR$ register.
}{
  $\XCR[*][{\VERB[RV]{crd}}] \ASN \RNG$ \;
}

% =============================================================================

\subsubsection{Class-$2.2$: memory}
\label{sec:spec:instruction:2:2}

These instructions allow multiple non-contiguous memory loads and stores
to be performed by a single instruction.
For a given data width, the instructions load or store one registers
worth of that data width to arbitrary addresses based on offsets stored
in another register.
This means that each instruction generates multiple memory transactions.
Implementations must adhere to the following rules with regard
to exceptions.
\begin{itemize}
\item Instructions in this class follow the normal rules for raising
    address misalignment exceptions as defined in the base RISC-V ISA.
\item All memory addresses generated by these instructions must
    be checked for misalignment {\em before} any memory transactions are
    issued.
\begin{itemize} \item
    For example, if the second transaction were to a misaligned address,
    the first transaction must not be issued.
    This restriction prevents any side effects out in the memory hierarchy
    and partial execution results from misaligned accesses.
    If the platform supports misaligned accesses, this case need not
    be considered.
\end{itemize}
\item Each memory transaction has the potential to generate an access
    fault which cannot be predicted until after the memory transaction
    has been issued.
    This may be a page fault or bus fault.
\begin{itemize}
\item In this case, partial execution results are not permitted.
    The destination register may not be updated unless all of the
    memory transactions complete successfully.
\item In the case of a page or bus fault, side effects in the
    memory hierarchy are permitted, though they should be avoided if
    possible.
\end{itemize}
\end{itemize}

% -----------------------------------------------------------------------------

\XCINSTR{xc.scatter.b}{crd, crs2, rs1}{
  Perform a ``scattered'' store of 
  four      bytes 
  from an $\XCR$ register
  into memory;
  for the $i$-th store, a base-offset style effective address is formed 
  from a
                     a  $\GPR$ register (the   base)
  plus
  a      byte within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\MEM[*][addr_0  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_1  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_2  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_3  ]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.scatter.h}{crd, crs2, rs1}{
  Perform a ``scattered'' store of 
  two  half-words
  from an $\XCR$ register
  into memory;
  for the $i$-th store, a base-offset style effective address is formed 
  from a
                     a  $\GPR$ register (the   base)
  plus
  a half-word within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\MEM[*][addr_0+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0}$ \;
  $\MEM[*][addr_0+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1}$ \;
  $\MEM[*][addr_1+0]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2}$ \;
  $\MEM[*][addr_1+1]                        \ASN \INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gather.b}{crd, crs2, rs1}{
  Perform a  ``gathered''  load of 
  four      bytes 
  from memory 
  into an $\XCR$ register;
  for the $i$-th  load, a base-offset style effective address is formed 
  from a
                     a  $\GPR$ register (the   base)
  plus
  a      byte within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $addr_2                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{2}$ \;
  $addr_3                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[ 8]{\XCR[*][{\VERB[RV]{crs2}}]}{3}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_1  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_2  ]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_3  ]$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.gather.h}{crd, crs2, rs1}{
  Perform a  ``gathered''  load of 
  two  half-words
  from memory 
  into an $\XCR$ register;
  for the $i$-th  load, a base-offset style effective address is formed 
  from a
                     a  $\GPR$ register (the   base)
  plus
  a half-word within an $\XCR$ register (the offset).
}{
  $addr_0                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{0}$ \;
  $addr_1                                   \ASN \GPR[*][{\VERB[RV]{rs1}}] + \INDEX[16]{\XCR[*][{\VERB[RV]{crs2}}]}{1}$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \MEM[*][addr_0+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \MEM[*][addr_0+1]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{2} \ASN \MEM[*][addr_1+0]$ \;
  $\INDEX[ 8]{\XCR[*][{\VERB[RV]{crd}}]}{3} \ASN \MEM[*][addr_1+1]$ \;
}

% =============================================================================

\subsubsection{Class-$2.3$: bit-oriented}
\label{sec:spec:instruction:2:3}

\XCINSTR{xc.ld.liu}{crd, imm16}{
  Load an immediate half-word
  into the lower (or least-significant) half-word of an $\XCR$ register, 
  leaving the other half-word in said register un-modified.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ld.hiu}{crd, imm16}{
  Load an immediate half-word
  into the upper (or  most-significant) half-word of an $\XCR$ register, 
  leaving the other half-word in said register un-modified.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{imm16} = \VERB[RV]{imm11} \CONS \VERB[RV]{imm5} .
  $
}{
  $\INDEX[16]{\XCR[*][{\VERB[RV]{crd}}]}{1} \ASN \VERB[RV]{imm16}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.bop}{crd, crs1, crs2, lut8}{
  Compute each $i$-bit of a $32$-bit result by applying a given $3$-input, 
  $1$-output Boolean function $f$ to corresponding $i$-th bits of the three
  operands.
  
  The function $f$ is specified as a truth-table encoded as the
  immediate \VERB[RV]{lut8}: given
  \[
  \begin{array}{|ccc|c|}
  \hline
  \multicolumn{4}{|c|}{f}     \\
  \hline
  x_i & y_i & z_i & r_i               \\
  \hline
    0 & 0 &   0 & \VERB[RV]{lut8}_0 \\
    0 & 0 &   1 & \VERB[RV]{lut8}_1 \\
    0 & 1 &   0 & \VERB[RV]{lut8}_2 \\
    0 & 1 &   1 & \VERB[RV]{lut8}_3 \\
    1 & 0 &   0 & \VERB[RV]{lut8}_4 \\
    1 & 0 &   1 & \VERB[RV]{lut8}_5 \\
    1 & 1 &   0 & \VERB[RV]{lut8}_6 \\
    1 & 1 &   1 & \VERB[RV]{lut8}_7 \\
  \hline
  \end{array}
  \]
  the instruction essentially computes
  $
  \INDEX{r}{i} = f( \INDEX{x}{i}, \INDEX{y}{i}, \INDEX{z}{i} ) = \INDEX{\VERB[RV]{lut8}}{x_i \CONS y_i \CONS z_i}
  $
  for $x$, $y$, $z$ and $r$, all in $\XCR$ registers.
  Note that
  \VERB[RV]{xc.bop}
  allows synthesis of a wider set of functionality; 
  for example, it can be used to synthesise a set of standard Boolean
  instructions (e.g., those in RV32I) by padding 
  \VERB[RV]{lut8} 
  appropriately per
  \[
  \begin{array}{l@{\;}c@{\;}l c l@{\;}c@{\;}l}
  \VERB[RV]{lut8} &=& \RADIX{10001000}{2} &\Longrightarrow& f &=& x \AND y \\
  \VERB[RV]{lut8} &=& \RADIX{11101110}{2} &\Longrightarrow& f &=& x \IOR y \\
  \VERB[RV]{lut8} &=& \RADIX{01100110}{2} &\Longrightarrow& f &=& x \XOR y \\
  \end{array}
  \]
}{
  \For{$i = 0$ {\bf upto} $31$} {
    $index \ASN \INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \CONS \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{i} \CONS \INDEX{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
    $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX{\VERB[RV]{lut8}}{index}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ext}{crd, crs1, start, length}{
  Extract a contiguous sequence of bits 
  from             one $\XCR$ register, and
  write them as the LSBs in another $\XCR$ register.
  The extracted bitfield is zero padded upto 
  the length of the destination register.
  The $\VERB[RV]{cs}$ field contains $\VERB[RV]{start}$ .
  The $\VERB[RV]{cl}$ field contains $\VERB[RV]{length}-1$.
  For an instruction word to decode as $\VERB[RV]{xc.ins}$,
  it is required that
  $\VERB[RV]{start} + \VERB[RV]{length}$ be less than or equal to
  the source register length.
}{
  $lo \ASN \VERB[RV]{cs}                $ \;
  $hi \ASN \VERB[RV]{cs} + \VERB[RV]{cl}$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{} \ASN \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{hi \RANGE lo}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.ins}{crd, crs1, start, length}{
  Insert a contiguous sequence of bits
  from the LSBs of one $\XCR$ register, into
  another $\XCR$ register at an arbitrary position.
  All other bits in the destination register are unaffected.
  The $\VERB[RV]{cs}$ field contains $\VERB[RV]{start}$ .
  The $\VERB[RV]{cl}$ field contains $\VERB[RV]{length}-1$.
  For an instruction word to decode as $\VERB[RV]{xc.ins}$,
  it is required that
  $\VERB[RV]{start} + \VERB[RV]{length}$ be less than or equal to
  the source register length.
}{
  $lo \ASN \VERB[RV]{cs}                $ \;
  $hi \ASN \VERB[RV]{cs} + \VERB[RV]{cl}$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{hi \RANGE lo}$ \ASN \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{\VERB[RV]{cl} \RANGE 0} \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.bmv}{crd, crs1, s, d}{
    Copy bit
    $\VERB[RV]{s}$
    of
    $\XCR[*][{\VERB[RV]{crs1}}]$
    into bit
    $\VERB[RV]{d}$
    of
    $\XCR[*][{\VERB[RV]{crd}}]$.
    All other destination register bits remain un-modified.
}{
  $s \ASN \VERB[RV]{cs}$ \;
  $d \ASN \VERB[RV]{cl}$ \;
  $\INDEX{\XCR[*][{\VERB[RV]{crd}}]}{d \RANGE d} \ASN \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{s \RANGE s}$ \;
}

% ----------------------------------------------------------------------------

\XCINSTR{xc.pbit}{crd, crs1, cs}{
    A generic permutation instruction.
    This instruction implements a 5-layer butterfly network.
    Each bit in each layer in the network can select one of two bits
    in the previous layer: itself, or another based on some function
    of it's position and layer (see $j'$ below).
    Each $\VERB[RV]{xc.pbit}$ instruction can activate upto 5 layers of
    the network.
    Repeated application of the instruction with different masks can
    achieve any 32-bit permutation in 30 instructions or fewer.
}{
    $t1 = \XCR[*][{\VERB[RV]{crd}}]$\;
    $t2 = 0$\;
    \For{$i=0$ {\bf upto} $4$}{
        \If{$\INDEX{\VERB[RV]{cs}}{i}$} {
            \For{$j=0$ {\bf upto} $32$}{

                $j' =  ((j+2^i) \% 2^{i+1})+(j/(2^{i+1}) * 2^{i+1})$ \;

                $ s = \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{j} ? j : j'$\;
                $\INDEX{t2}{j} =  \INDEX{\VERB[RV]{t1}}{s} $ \;
            }
            $t1 = t2$\;
        }
    }
    $\XCR[*][{\VERB[RV]{crd}}] = t1$ \;
}

% ----------------------------------------------------------------------------

\XCINSTR{xc.ipbit}{crd, crs1, cs}{
    A generic inverse permutation instruction.
    Works just like the $\VERB[RV]{xc.pbit}$ instruction, but
    propagates backwards through the buterfly network.
}{
    $t1 = \XCR[*][{\VERB[RV]{crd}}]$\;
    $t2 = 0$\;
    \For{$i=0$ {\bf upto} $4$}{
        \If{$\INDEX{\VERB[RV]{cs}}{i}$} {
            \For{$j=0$ {\bf upto} $32$}{
                $k=4-i$ \;
                $j' =  ((j+2^k) \% 2^{k+1})+(j/(2^{k+1}) * 2^{k+1})$ \;
                $ s = \INDEX{\XCR[*][{\VERB[RV]{crs1}}]}{j} ? j : j'$\;
                $\INDEX{t2}{j} =  \INDEX{\VERB[RV]{t1}}{s} $ \;
            }
            $t1 = t2$\;
        }
    }
    $\XCR[*][{\VERB[RV]{crd}}] = t1$ \;
}

\XCINSTR{xc.pbyte}{crd, crs1, b0, b1, b2, b3}{
    A byte level permutation instruction. Allows any byte in a source
    word to be placed in any byte of a destination word.
    This instruction can be used for fast endianness manipulation, and
    a faster way to implement some permutation layers of the
    $\VERB[RV]{xc.pbit}$ and 
    $\VERB[RV]{xc.ipbit}$
    instructions.
}{
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crs1}}]}{b0}$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crs1}}]}{b1}$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crs1}}]}{b2}$ \;
    $\INDEX[8]{\XCR[*][{\VERB[RV]{crd}}]}{0} \ASN \INDEX[8]{\XCR[*][{\VERB[RV]{crs1}}]}{b3}$ \;
}

% ----------------------------------------------------------------------------

\XCINSTR{xc.lut}{crd, crs1, crs2, crs3}{
  Apply an arbitrary $4$-bit input, $4$-bit output Look-up Table (LUT) 
  to the contents of 
  $\XCR[*][{\VERB[RV]{crs1}}]$,
  placing the result in
  $\XCR[*][{\VERB[RV]{crd}}]$.
  The LUT is specified by
  $
  \XCR[*][{\VERB[RV]{crs2}}]$ and $\XCR[*][{\VERB[RV]{crs3}}] ,
  $
  allowing definition of
  \[
  lut[i] = \INDEX[4]{{(\XCR[*][{\VERB[RV]{crs3}}] \CONS \XCR[*][{\VERB[RV]{crs2}}])}}{i}
  \]
  for each $0 \leq i < 15$.  For example, if 
  $
  \XCR[*][{\VERB[RV]{crs2}}] = \RADIX{ABCD1234}{16}
  $
  and
  $
  \XCR[*][{\VERB[RV]{crs3}}] = \RADIX{456789EF}{16}
  $
  then 
  $lut[0] = \RADIX{4}{16}$, 
  $lut[1] = \RADIX{3}{16}$,
  $lut[7] = \RADIX{A}{16}$ 
  and 
  $lut[8] = \RADIX{F}{16}$.

  Note that
  \VERB[RV]{xc.lut}
  allows synthesis of a wider set of functionality; 
  for example, application of a $2$-bit input, $2$-bit output LUT can 
  be synthesised by padding
  $
  \XCR[*][{\VERB[RV]{crs2}}]$ and $\XCR[*][{\VERB[RV]{crs3}}]
  $
  appropriately.
}{
  \For{$i=0$ {\bf upto} $15$}{
    \INDEX[4]{\XCR[*][{\VERB[RV]{crd}}]}{i} = lut[\INDEX[4]{\XCR[*][{\VERB[RV]{crs1}}]}{i}]
  }
}

% =============================================================================

\subsubsection{Class-$2.4$: packed}
\label{sec:spec:instruction:2:4}

Each instruction in this class computes a packed operation: for an operator
$\odot$, register or immediate variants essentially compute

\begin{enumerate}
\item $\INDEX[w]{r}{i} = \INDEX[w]{x}{i} \OP[w][u]{\odot} \INDEX[w]{y}{i}$,
      for $r$, $x$, and $y$ in $\XCR$ registers.
      and
\item $\INDEX[w]{r}{i} = \INDEX[w]{x}{i} \OP[w][u]{\odot}           y    $,
      for $r$       and $x$ in $\XCR$ registers, and an immediate $y$,
\end{enumerate}

\noindent
and for each 
$
0 \leq i < \VERB[RV]{n} ,
$ 
where the field count
$
\VERB[RV]{n} \in \SET{ 2, 4, 8, 16, 32 }
$ 
specified in the instruction encoding implies a field width of 
$
w = 32 / \VERB[RV]{n} .
$
As such, said encoding yields the following cases
\[
\begin{array}{ccrcc@{\;}c@{\;}rc@{\;}c@{\;}r}
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{000}{2} &\mapsto& \VERB[RV]{n} &=&  1 & w &=& 32     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{001}{2} &\mapsto& \VERB[RV]{n} &=&  2 & w &=& 16     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{010}{2} &\mapsto& \VERB[RV]{n} &=&  4 & w &=&  8     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{011}{2} &\mapsto& \VERB[RV]{n} &=&  8 & w &=&  4     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{100}{2} &\mapsto& \VERB[RV]{n} &=&  1 & w &=& 32     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{101}{2} &\mapsto& \VERB[RV]{n} &=& 16 & w &=&  2     \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{110}{2} &\mapsto& \multicolumn{6}{c}{\mbox{invalid}} \\
\VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} &=& \RADIX{111}{2} &\mapsto& \multicolumn{6}{c}{\mbox{invalid}} \\
\end{array}
\]
where cases marked invalid are reserved.  Note that the encoding 
$
\RADIX{100}{2}
$
is valid only for the instructions
\VERB[RV]{xc.psll.i},
\VERB[RV]{xc.psrl.i} and
\VERB[RV]{xc.prot.i}.
In this case, the \VERB[RV]{ca} bit is used to encode the most significant
bit of the shift/rotate amount; for all other instructions, the encoding
is considered invalid.

% -----------------------------------------------------------------------------

\XCINSTR{xc.padd}{pw, crd, crs1, crs2}{
  Compute a   register-based packed addition, 
  implying $\odot = +$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{+}      \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psub}{pw, crd, crs1, crs2}{
  Compute a   register-based packed subtraction, 
  implying $\odot = -$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{-}      \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pmul.l}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication,
  implying $\odot = \times$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the  ``low'' half, or $w$ LSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pmul.h},   which captures the ``high'' half, or $w$ MSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{ \times} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{        w - 1 \RANGE 0}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pmul.h}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication,
  implying $\odot = \times$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the ``high'' half, or $w$ MSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pmul.l},   which captures the  ``low'' half, or $w$ LSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{ \times} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{2 \cdot w - 1 \RANGE w}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pclmul.l}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication in $\B{F}_2[\IND{x}]$ (or ``carry-less'' multiplication),
  implying $\odot = \otimes$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the  ``low'' half, or $w$ LSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pclmul.h}, which captures the ``high'' half, or $w$ MSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\otimes} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{        w - 1 \RANGE 0}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.pclmul.h}{pw, crd, crs1, crs2}{
  Compute a   register-based packed multiplication in $\B{F}_2[\IND{x}]$ (or ``carry-less'' multiplication),
  implying $\odot = \otimes$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that this instruction captures the ``high'' half, or $w$ MSBs of 
  each computed product
  (cf. \VERB[RV]{xc.pclmul.l}, which captures the  ``low'' half, or $w$ LSBs).
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $t \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\otimes} \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN t_{2 \cdot w - 1 \RANGE w}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psll}{pw, crd, crs1, crs2}{
  Compute a   register-based packed left-shift,
  implying $\odot = \LSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LSH}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psll.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed left-shift,
  implying $\odot = \LSH$.
  Note that any out-of-range distance
  $
  \VERB[RV]{shamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
  Valid shift amounts for field width $w=32$ are $0 \le x \le 31$.
  Valid shift amounts for field widths $w<32$ are $0 \le x \le 15$.
  When $w=32$, the {\tt ca} field is used to encode the MSB of the shift amount.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \eIf{$w = 32$}{
    $shamt = ca \CONS cshamt $\;
  }{
    $shamt = 0  \CONS cshamt $\;
  }
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\LSH}   \VERB[RV]{shamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psrl}{pw, crd, crs1, crs2}{
  Compute a   register-based packed right-shift,
  implying $\odot = \RSH$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RSH}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs2}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.psrl.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed left-shift,
  implying $\odot = \RSH$.
  Note that any out-of-range distance
  $
  \VERB[RV]{shamt} \geq w
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} = 0 .
  $
  Valid shift amounts for field width $w=32$ are $0 \le x \le 31$.
  Valid shift amounts for field widths $w<32$ are $0 \le x \le 15$.
  When $w=32$, the {\tt ca} field is used to encode the MSB of the shift amount.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \eIf{$w = 32$}{
    $shamt = ca \CONS cshamt $\;
  }{
    $shamt = 0  \CONS cshamt $\;
  }
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RSH}   \VERB[RV]{shamt}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.prot}{pw, crd, crs1, crs2}{
  Compute a   register-based packed right-rotate,
  implying $\odot = \RRT$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{n} = 1 \LSH ( \VERB[RV]{ca} \CONS \VERB[RV]{cb} \CONS \VERB[RV]{cc} ) ,
  $
  and that the effective distance is
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \pmod{w} .
  $
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RRT}   \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i}$ \;
  }
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.prot.i}{pw, crd, crs1, cshamt}{
  Compute an immediate-based packed right-rotate,
  implying $\odot = \RRT$.
  Note that the effective distance is
  $
  \VERB[RV]{rtamt} \pmod{w} .
  $
  Valid shift amounts for field width $w=32$ are $0 \le x \le 31$.
  Valid shift amounts for field widths $w<32$ are $0 \le x \le 15$.
  When $w=32$, the {\tt ca} field is used to encode the MSB of the shift amount.
}{
  $w = 32 / \VERB[RV]{n}$ \;
  \eIf{$w = 32$}{
    $rtamt = ca \CONS cshamt $\;
  }{
    $rtamt = 0  \CONS cshamt $\;
  }
  \For{$i = 0$ {\bf upto} $\VERB[RV]{n} - 1$}{
    $\INDEX[w]{\XCR[*][{\VERB[RV]{crd}}]}{i} \ASN \INDEX[w]{\XCR[*][{\VERB[RV]{crs1}}]}{i} \OP[w][u]{\RRT}   \VERB[RV]{rtamt}$ \;
  }
}

% =============================================================================

\subsubsection{Class-$2.5$: multi-precision}
\label{sec:spec:instruction:2:5}

Instructions in this class use upto
$4$ source      $\XCR$ registers
and
$2$ destination $\XCR$ registers,
which demands some compromises wrt. the encoding used.
In short, a compressed specification of the destination $\XCR$ registers is
used, whereby a single encoded \VERB[RV]{crdm} field implies (or maps to) a 
pair 
$
\TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} }
$
of register addresses st.
a) $\VERB[RV]{crd2} = \VERB[RV]{crd1} + 1$
   (the contiguous'ness rule),
   and
b) $\VERB[RV]{crd2} = 1 \pmod{2}$
   and 
   $\VERB[RV]{crd1} = 0 \pmod{2}$
   (the  odd-even'ness rule).
Concretely then, this means
\[
\begin{array}{l@{\;}c@{\;}r c c@{\;}l@{\;}c@{\;}r@{\;}c@{\;}l@{\;}c@{\;}r@{\;}c}
\VERB[RV]{crdm} &=& \RADIX{000}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  1 &,& \VERB[RV]{crd1} &=&  0 & ) \\
\VERB[RV]{crdm} &=& \RADIX{001}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  3 &,& \VERB[RV]{crd1} &=&  2 & ) \\
\VERB[RV]{crdm} &=& \RADIX{010}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  5 &,& \VERB[RV]{crd1} &=&  4 & ) \\
\VERB[RV]{crdm} &=& \RADIX{011}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  7 &,& \VERB[RV]{crd1} &=&  6 & ) \\
\VERB[RV]{crdm} &=& \RADIX{100}{2} &\mapsto& ( & \VERB[RV]{crd2} &=&  9 &,& \VERB[RV]{crd1} &=&  8 & ) \\
\VERB[RV]{crdm} &=& \RADIX{101}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 11 &,& \VERB[RV]{crd1} &=& 10 & ) \\
\VERB[RV]{crdm} &=& \RADIX{110}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 13 &,& \VERB[RV]{crd1} &=& 12 & ) \\
\VERB[RV]{crdm} &=& \RADIX{111}{2} &\mapsto& ( & \VERB[RV]{crd2} &=& 15 &,& \VERB[RV]{crd1} &=& 14 & ) \\
\end{array}
\]
i.e.,
\[
\VERB[RV]{crdm} = x ~~\mapsto~~ \TUPLE{ \VERB[RV]{crd2} = x \CONS 1 , \VERB[RV]{crd1} = x \CONS 0 } ,
\]
noting
$\TUPLE{ 1, 0 }$ and $\TUPLE{ 3, 2 }$ are deemed valid pairs,
$\TUPLE{ 3, 0 }$ is invalid because it violates the contiguous'ness rule,
$\TUPLE{ 2, 3 }$ is invalid because it violates the contiguous'ness rule,
and
$\TUPLE{ 2, 1 }$ is invalid because it violates the  odd-even'ness rule.

% -----------------------------------------------------------------------------

\XCINSTR{xc.madd.2}{(crd2, crd1), crs1, crs2      }{
  Compute a   register-based multi-precision (or ``long'') addition:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the addends,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the sum,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the carry-out,
  meaning the instruction acts as a word-oriented analogue of a half-adder.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.madd.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') addition:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the addends,
  $\XCR[*][{\VERB[RV]{crs3}}]$ as the carry-in,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the sum,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the carry-out,
  meaning the instruction acts as a word-oriented analogue of a full-adder.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{+}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{+} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msub.2}{(crd2, crd1), crs1, crs2      }{
  Compute a   register-based multi-precision (or ``long'') subtraction:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$ as the    minuend,
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the subtrahend,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the difference,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the borrow-out,
  meaning the instruction acts as a word-oriented analogue of a half-subtractor.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] )  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msub.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') subtraction:
  one can interpret
  $\XCR[*][{\VERB[RV]{crs1}}]$ as the    minuend,
  $\XCR[*][{\VERB[RV]{crs2}}]$ as the subtrahend,
  $\XCR[*][{\VERB[RV]{crs3}}]$ as the borrow-in,
  $\XCR[*][{\VERB[RV]{crd1}}]$ as the difference,
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ as the borrow-out,
  meaning the instruction acts as a word-oriented analogue of a full-subtractor.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[64][u]{-}        \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{-} \INDEX{\XCR[*][{\VERB[RV]{crs3}}]}{0}  $ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.macc.1}{(crd2, crd1), crs1      }{
  Compute a   register-based multi-precision (or ``long'') accumulation,
  with the
  $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs1}}]$
  accumulated into a $64$-bit value formed by concatenating
  $\XCR[*][{\VERB[RV]{crd1}}]$
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.macc.2}{(crd2, crd1), crs1, crs2}{
  Compute a   register-based multi-precision (or ``long'') accumulation,
  with the
  $32$-bit addends
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  accumulated into a $64$-bit value formed by concatenating
  $\XCR[*][{\VERB[RV]{crd1}}]$
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crd2}}] \CONS \XCR[*][{\VERB[RV]{crd1}}] ) \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs1}}] 
                                                                                                   \OP[64][u]{+} \XCR[*][{\VERB[RV]{crs2}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mmul.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') multiply-accumulate:
  the $32$-bit multiplicands
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  are first used to form a $64$-bit product captured by
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs),
  into which the $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs3}}]$
  is accumulated.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{ \times} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{ +}      \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mclmul.3}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') multiply-accumulate in $\B{F}_2[\IND]$:
  the $32$-bit multiplicands
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$
  are first used to form a $64$-bit product captured by
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs),
  into which the $32$-bit addend
  $\XCR[*][{\VERB[RV]{crs3}}]$
  is accumulated.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs1}}] \OP[32][u]{\otimes} \XCR[*][{\VERB[RV]{crs2}}] ) 
                                                                \OP[64][u]{\oplus}  \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msll}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'')  left-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then  left-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs3}}]}{i} \geq 64
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd1}}]}{i} = \INDEX[w]{\XCR[*][{\VERB[RV]{crd2}}]}{i} = 0 .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\LSH} \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msll.i}{(crd2, crd1), crs1, crs2, shamt}{
  Compute an immediate-based multi-precision (or ``long'')  left-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then  left-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\LSH} \VERB[RV]{cmshamt}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msrl}{(crd2, crd1), crs1, crs2, crs3}{
  Compute a   register-based multi-precision (or ``long'') right-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then right-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } ,
  $
  and that any out-of-range distance
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crs3}}]}{i} \geq 64
  $
  will yield
  $
  \INDEX[w]{\XCR[*][{\VERB[RV]{crd1}}]}{i} = \INDEX[w]{\XCR[*][{\VERB[RV]{crd2}}]}{i} = 0 .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\RSH} \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.msrl.i}{(crd2, crd1), crs1, crs2, shamt}{
  Compute an immediate-based multi-precision (or ``long'') right-shift:
  a $64$-bit value is formed by concatenating
  $\XCR[*][{\VERB[RV]{crs1}}]$
  and
  $\XCR[*][{\VERB[RV]{crs2}}]$, 
  then right-shifted to yield a result in 
  $\XCR[*][{\VERB[RV]{crd1}}]$ (the LSBs)
  and
  $\XCR[*][{\VERB[RV]{crd2}}]$ (the MSBs).
  Note that, wrt. the encoding,
  $
  \VERB[RV]{crdm} \mapsto \TUPLE{ \VERB[RV]{crd2}, \VERB[RV]{crd1} } .
  $
}{
  $t                          \ASN ( \XCR[*][{\VERB[RV]{crs2}}] \CONS \XCR[*][{\VERB[RV]{crs1}}] ) \OP[64][u]{\RSH} \VERB[RV]{cmshamt}$ \;
  $\XCR[*][{\VERB[RV]{crd1}}] \ASN \INDEX{t}{31 \RANGE  0}$ \;
  $\XCR[*][{\VERB[RV]{crd2}}] \ASN \INDEX{t}{64 \RANGE 32}$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mequ}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
  equality 
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_0            \AND \GPR[*][{\VERB[RV]{rs1}}]  $ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mlte}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
     less-than
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $t_1 \ASN \XCR[*][{\VERB[RV]{crs2}}] < \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_1 \IOR ( t_0 \AND \GPR[*][{\VERB[RV]{rs1}}] )$ \;
}

% -----------------------------------------------------------------------------

\XCINSTR{xc.mgte}{rd, rs1, crs2, crs3}{
  Compute a ``chained'' (or ``long'') 
  greater-than
  comparison between
  $\XCR[*][{\VERB[RV]{crs2}}]$
  and
  $\XCR[*][{\VERB[RV]{crs3}}]$,
  forming some $i$-th step within a multi-precision comparison.
}{
  $t_0 \ASN \XCR[*][{\VERB[RV]{crs2}}] = \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $t_1 \ASN \XCR[*][{\VERB[RV]{crs2}}] > \XCR[*][{\VERB[RV]{crs3}}]$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN t_1 \IOR ( t_0 \AND \GPR[*][{\VERB[RV]{rs1}}] )$ \;
}

% -----------------------------------------------------------------------------

\subsubsection{Class-$3.1$: AES}
\label{sec:spec:instruction:3:1}

\XCINSTR{xc.aessub}{.\[enc,dec\]\[rot\] crd, crs1, crs2}{
  Per~\cite[Figures 5]{SCARV:TilGro:06}, 
  apply a (carefully structured) form of the AES 
  {\tt SubBytes}~\cite[Section 5.1.1]{SCARV:FIPS:197}
  operation:
  this is applicable to a column-oriented implementation of AES, whereby
  columns of the state (resp. round key) matrix are packed into $32$-bit
  words.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{mode}
  $
  and
  $
  \VERB[RV]{rot}
  $
  control  which variant is applied: these variants are exposed via
  dedicated mnemonics st.
  \[
  \begin{array}{l c r@{\;}c@{\;}l @{\;}c@{\;} r@{\;}c@{\;}l}
  \VERB[RV]{xc.aessub.enc}    &\mapsto& \VERB[RV]{mode} &=& 0 &,& \VERB[RV]{rot} &=& 0 \\
  \VERB[RV]{xc.aessub.encrot} &\mapsto& \VERB[RV]{mode} &=& 0 &,& \VERB[RV]{rot} &=& 1 \\
  \VERB[RV]{xc.aessub.dec}    &\mapsto& \VERB[RV]{mode} &=& 1 &,& \VERB[RV]{rot} &=& 0 \\
  \VERB[RV]{xc.aessub.decrot} &\mapsto& \VERB[RV]{mode} &=& 1 &,& \VERB[RV]{rot} &=& 1 \\
  \end{array}
  \]
  $\VERB[RV]{mode}$ is encoded in the $\VERB[RV]{ca}$ field and
  $\VERB[RV]{rot}$  is encoded in the $\VERB[RV]{cb}$ field.
}{
  \eIf{$\VERB[RV]{mode} = 0$}{
    $t_0                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][{\VERB[RV]{crs1}}]_{ 7 \RANGE  0} )$ \;
    $t_1                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][{\VERB[RV]{crs2}}]_{15 \RANGE  8} )$ \;
    $t_2                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][{\VERB[RV]{crs1}}]_{23 \RANGE 16} )$ \;
    $t_3                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}     ( \XCR[*][{\VERB[RV]{crs2}}]_{31 \RANGE 24} )$ \;
  }{
    $t_0                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][{\VERB[RV]{crs1}}]_{ 7 \RANGE  0} )$ \;
    $t_1                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][{\VERB[RV]{crs2}}]_{15 \RANGE  8} )$ \;
    $t_2                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][{\VERB[RV]{crs1}}]_{23 \RANGE 16} )$ \;
    $t_3                        \ASN \SCOPE{\ID{AES}}{\ALG{S-box}}^{-1}( \XCR[*][{\VERB[RV]{crs2}}]_{31 \RANGE 24} )$ \;
  }
  
  \eIf{$\VERB[RV]{rot}  = 0$}{
    $\XCR[*][{\VERB[RV]{crd0}}] \ASN                                          t_3 \CONS t_2 \CONS t_1 \CONS t_0 $ \;
  }{
    $\XCR[*][{\VERB[RV]{crd0}}] \ASN                                          t_2 \CONS t_1 \CONS t_0 \CONS t_3 $ \;
  }
}

\XCINSTR{xc.aesmix}{mode,      crd, crs1, crs2}{
  Per~\cite[Figures 5]{SCARV:TilGro:06}, 
  apply a (carefully structured) form of the AES 
  {\tt ShiftRows}~\cite[Section 5.1.2]{SCARV:FIPS:197} 
  and
  {\tt MixColumns}~\cite[Section 5.1.3]{SCARV:FIPS:197}
  operations:
  this is applicable to a column-oriented implementation of AES, whereby
  columns of the state (resp. round key) matrix are packed into $32$-bit
  words.
  Note that, wrt. the encoding,
  $
  \VERB[RV]{mode}
  $
  controls which variant is applied: these variants are exposed via
  dedicated mnemonics st.
  \[
  \begin{array}{l c r@{\;}c@{\;}l@{\;}}
  \VERB[RV]{xc.aesmix.enc}    &\mapsto& \VERB[RV]{mode} &=& 0                          \\
  \VERB[RV]{xc.aesmix.dec}    &\mapsto& \VERB[RV]{mode} &=& 1                          \\
  \end{array}
  \]
  $\VERB[RV]{mode}$ is encoded in the $\VERB[RV]{ca}$ field.
}{
    $t_0                        \ASN                                     \XCR[*][{\VERB[RV]{crs1}}]_{ 7 \RANGE  0}  $ \;
    $t_1                        \ASN                                     \XCR[*][{\VERB[RV]{crs1}}]_{15 \RANGE  8}  $ \;
    $t_2                        \ASN                                     \XCR[*][{\VERB[RV]{crs2}}]_{23 \RANGE 16}  $ \;
    $t_3                        \ASN                                     \XCR[*][{\VERB[RV]{crs2}}]_{31 \RANGE 24}  $ \;

  \eIf{$\VERB[RV]{mode} = 0$}{
    $\XCR[*][{\VERB[RV]{crd0}}] \ASN \SCOPE{\ID{AES}}{\ALG{Mix-Column}}     ( t_3 \CONS t_2 \CONS t_1 \CONS t_0 )$ \;
  }{
    $\XCR[*][{\VERB[RV]{crd0}}] \ASN \SCOPE{\ID{AES}}{\ALG{Mix-Column}}^{-1}( t_3 \CONS t_2 \CONS t_1 \CONS t_0 )$ \;
  }
}

% -----------------------------------------------------------------------------

\subsubsection{Class-$3.2$: SHA3}
\label{sec:spec:instruction:3:2}

Each instruction in this class computes an index into the SHA3 state array:
they provide domain-specific support for address generation within the step
mappings~\cite[Section 3.2]{SCARV:FIPS:202} (i.e., $\Omega$, $\rho$, $\pi$, 
$\chi$, and $\iota$) that constitute each round.  Note that

\begin{itemize}
\item the $2$-bit immediate \VERB[RV]{shamt} can be used align the index 
      to a byte, half-word, word, or double-word boundary 
      (and thereby support all SHA3 parameterisations), 
      and
\item the instructions use $\GPR$ rather than $\XCR$: this is explained by
      their focus on addressing, vs. computation per se.
\end{itemize}

\XCINSTR{xc.sha3.xy}{rd, rs1, rs2, shamt}{
  Compute an index into the SHA3 state array.
}{
  $x                        \ASN \GPR[*][{\VERB[RV]{rs1}}]_{4 \RANGE 0}$ \;
  $y                        \ASN \GPR[*][{\VERB[RV]{rs2}}]_{4 \RANGE 0}$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( (   x       \bmod 5 ) + 5 \cdot (                       y   \bmod 5 ) ) \LSH \VERB[RV]{shamt}$ \;
}

\XCINSTR{xc.sha3.x1}{rd, rs1, rs2, shamt}{
  Compute an index into the SHA3 state array.
}{
  $x                        \ASN \GPR[*][{\VERB[RV]{rs1}}]_{4 \RANGE 0}$ \;
  $y                        \ASN \GPR[*][{\VERB[RV]{rs2}}]_{4 \RANGE 0}$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( ( ( x + 1 ) \bmod 5 ) + 5 \cdot (                       y   \bmod 5 ) ) \LSH \VERB[RV]{shamt}$ \;
}

\XCINSTR{xc.sha3.x2}{rd, rs1, rs2, shamt}{
  Compute an index into the SHA3 state array.
}{
  $x                        \ASN \GPR[*][{\VERB[RV]{rs1}}]_{4 \RANGE 0}$ \;
  $y                        \ASN \GPR[*][{\VERB[RV]{rs2}}]_{4 \RANGE 0}$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( ( ( x + 2 ) \bmod 5 ) + 5 \cdot (                       y   \bmod 5 ) ) \LSH \VERB[RV]{shamt}$ \;
}

\XCINSTR{xc.sha3.x4}{rd, rs1, rs2, shamt}{
  Compute an index into the SHA3 state array.
}{
  $x                        \ASN \GPR[*][{\VERB[RV]{rs1}}]_{4 \RANGE 0}$ \;
  $y                        \ASN \GPR[*][{\VERB[RV]{rs2}}]_{4 \RANGE 0}$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( ( ( x + 4 ) \bmod 5 ) + 5 \cdot (                       y   \bmod 5 ) ) \LSH \VERB[RV]{shamt}$ \;
}

\XCINSTR{xc.sha3.yx}{rd, rs1, rs2, shamt}{
  Compute an index into the SHA3 state array.
}{
  $x                        \ASN \GPR[*][{\VERB[RV]{rs1}}]_{4 \RANGE 0}$ \;
  $y                        \ASN \GPR[*][{\VERB[RV]{rs2}}]_{4 \RANGE 0}$ \;
  $\GPR[*][{\VERB[RV]{rd}}] \ASN ( (   y       \bmod 5 ) + 5 \cdot ( ( 2 \cdot x + 3 \cdot y ) \bmod 5 ) ) \LSH \VERB[RV]{shamt}$ \;
}

% =============================================================================
