% =============================================================================

\subsection{Assumptions}
\label{sec:bg:assumption}

\begin{itemize}

\item We make no assumption about the value of $\RVXLEN$ for the base
      architecture which \XCID extends.
      \XCID is explicitly designed for use with microcontrollers, so
      some design decisions will make more sense when considering
      $\RVXLEN=32$.

\item We use an analogous variable $\XCLEN$, defined in section
     \ref{sec:spec:state:xcr}, to denote the width of additional \XCID
     state.

\item \XCID demands interaction with an RNG, the concrete instantiation of 
      which is unspecified: we assume the RNG design follows best-practice,
      e.g., per NIST~\cite{SCARV:NIST:SP:800_90a,SCARV:NIST:SP:800_90b,SCARV:NIST:SP:800_90c},
      and has an interface per \cite[Section 6.4]{SCARV:NIST:SP:800_90c}.

      On one hand, doing so affords flexibility in an implementation; this 
      is important, in that an RNG selection and implementation will likely 
      be technology-specific (e.g., differ for a given FPGA, vs. an ASIC).  
      On the other hand, however, the RNG used is critically important wrt. 
      security: the (difficult) challenge of selecting and implementing 
      a robust RNG instance is assumed to be addressed.

\item \XCID assumes a byte-addressable memory, the interface to which will
      be shared between the host core and co-processor.  As such, {\em all}
      attack vectors
      (see, e.g.,~\cite{SCARV:GYCH:18})
      that (ab)use the memory interface {\em must} be robustly mitigated, 
      as would be the case without \XCID (i.e., using the host core alone).

\end{itemize}

% =============================================================================
