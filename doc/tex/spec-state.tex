\subsection{\XCID state}
\label{sec:spec:state}

It is important to recognise the overhead, wrt. both 
time  (e.g., due to it needing to be context switched) 
and 
space (e.g., wrt. additional logic),
relating to {\em any} state added by \XCID.
However, it also seems reasonable to align the trade-off(s) involved with 
existing, common cases such as ISEs for floating-point arithmetic (namely
the standard 
F~\cite[Section 8]{SCARV:RV:ISA:I:17}
and
D~\cite[Section 9]{SCARV:RV:ISA:I:17}
extensions).  The addition of a dedicated floating-point register file is
rationalised, for example, by
a) clear separation of duty,
b) additional capacity, leading, e.g., to enhanced performance,
   and
c) additional (specialised) functionality;
a similar argument is true of \XCID, but motivated by a different context
(i.e., cryptographic vs. floating-point workloads).

Note that, 
particularly due to the nature of workloads supported by \XCID,
challenges relating to management of additional state are important.  For
example, attack vectors such as 
LazyFP~\cite{SCARV:StePre:18}, 
which capitalises on a short-cut wrt. the overhead of context switching
x87 state, {\em must} be robustly mitigated.

% =============================================================================

\subsubsection{$\XCR$ register file}
\label{sec:spec:state:xcr}

\XCID 
requires one additional 
$16$-element, $\XCLEN$-bit register file.
We refer to this as the $\XCR$ register file, distinguishing it from the
general-purpose $\GPR$ register file specified by the base ISA.
Note that

\begin{itemize}
\item Upon reset of \XCID,
            the $\XCR$ register file {\em must} be reset (cf.~\REFSEC{sec:spec:instruction:xc.init}).
\item RISC-V specifies~\cite[Section 2.1]{SCARV:RV:ISA:I:17} that
      $
      \GPR[*][0] = 0 ,
      $
      i.e., that the $0$-th $\GPR$ register is fixed to $0$: any read from 
      said register yields $0$.  The analogous special-case is {\em not} 
      true of 
      $
      \XCR[*][0] ,
      $
      the $0$-th $\XCR$ register.
\item The $\XCR$ register file is used {\em exclusively} by \XCID, but, on
      the other hand, \XCID can {\em also} use the $\GPR$ register file in 
      selected cases.  For example, it uses a $\GPR$ register as

      \begin{itemize}
      \item a source, specifically a base address, for memory accesses,
            (e.g., \VERB[RV]{xc.ld.w} and \VERB[RV]{xc.st.w}; see \REFSEC{sec:spec:instruction:xc.ld.w} and \REFSEC{sec:spec:instruction:xc.st.w}),
      \item a destination for comparison operations,
            (e.g., \VERB[RV]{xc.mequ}; see \REFSEC{sec:spec:instruction:xc.mequ}).
      \end{itemize}

      \noindent
      Doing so aligns with \REFSEC{sec:bg:concept}, where the host core is 
      pitched as a control-path for the co-processor: address computation,
      control-flow orchestration, etc. fall under the remit of the former, 
      since they can be supported by the base ISA as is.
\end{itemize}    

% =============================================================================

\subsubsection{Control and Status Registers (CSRs)}
\label{sec:spec:state:csr}

\begin{table}[p]
\begin{center}
\begin{tabular}{|ccc|}
\hline
Name          & Address         & Access     \\ 
\hline
$\SPR{mxcsr}$ & \RADIX{7C0}{16} & read/write \\
$\SPR{sxcsr}$ & \RADIX{DC0}{16} & read/write \\
$\SPR{uxcsr}$ & \RADIX{CC0}{16} & read       \\
\hline
\end{tabular}
\end{center}
\caption{A summary of \XCID CSRs, per~\cite[Table 2.1]{SCARV:RV:ISA:II:17}.}
\label{tab:csr}
\end{table}

\begin{figure}[p]
\begin{center}
\begin{bytefield}[bitwidth={1.4em},bitheight={8.0ex},endianness=big]{32}
\bitheader{0-31}               
\\
  \bitbox{15}{\rule{\width}{\height}}
& \bitbox{ 1}{\rule{\width}{\height}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{SHA3}     $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{AES }     $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{PACK}_{16}$}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{PACK}_{ 8}$}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{PACK}_{ 4}$}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{PACK}_{ 2}$}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{PACK}_{ 1}$}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{MP  }     $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{BIT }     $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{MEM }     $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{RNG }     $}}
& \bitbox{ 2}{\rotatebox{90}{\tiny $\ID{XS  }     $}}
& \bitbox{ 1}{\rule{\width}{\height}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{S   }     $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $\ID{U   }     $}}
\\
\end{bytefield}
\end{center}
\caption{A diagrammatic description of the $\SPR{mxcsr}$ register; blanked regions are reserved, so yield zero when the register is read.}
\label{fig:mxcsr}
\end{figure}

\begin{table}[p]
\begin{center}
\begin{tabular}{|l|c|c|l|}
\hline
Field             & Index          & Access & Description                                                                         \\ 
\hline
$\ID{U   }      $ & $           0$ & WLRL   & Indicates whether or not \XCID is accessible in user mode                           \\
$\ID{S   }      $ & $           1$ & WLRL   & Indicates whether or not \XCID is accessible in supervisor mode                     \\
$\ID{XS  }      $ & $ 4 \RANGE  3$ & R/O    & Indicates whether or not the \XCID state is dirty                                   \\
$\ID{RNG }      $ & $           5$ & R/O    & Is RNG  feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\
$\ID{MEM }      $ & $           6$ & R/O    & Is MEM  feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\
$\ID{BIT }      $ & $           7$ & R/O    & Is BIT  feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\
$\ID{MP  }      $ & $           8$ & R/O    & Is MP   feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\
$\ID{PACK}_{ 1} $ & $           9$ & R/O    & Are operations on sub-word  of $w = 32$ bits supported (set), or not (clear)        \\
$\ID{PACK}_{ 2} $ & $          10$ & R/O    & Are operations on sub-words of $w = 16$ bits supported (set), or not (clear)        \\
$\ID{PACK}_{ 4} $ & $          11$ & R/O    & Are operations on sub-words of $w =  8$ bits supported (set), or not (clear)        \\
$\ID{PACK}_{ 8} $ & $          12$ & R/O    & Are operations on sub-words of $w =  4$ bits supported (set), or not (clear)        \\
$\ID{PACK}_{16} $ & $          13$ & R/O    & Are operations on sub-words of $w =  2$ bits supported (set), or not (clear)        \\
$\ID{AES }      $ & $          14$ & R/O    & Is AES  feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\
$\ID{SHA3}      $ & $          15$ & R/O    & Is SHA3 feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\ 
\hline
\end{tabular}
\end{center}
\caption{A tabular description of the $\SPR{mxcsr}$ register.}
\label{tab:mxcsr}
\end{table}

\XCID 
requires three additional
non-standard CSRs~\cite[Section 2]{SCARV:RV:ISA:II:17},
outlined by \REFTAB{tab:csr}.
In practice, only {\em one} additional register is required for
$\SPR{mxcsr}$; $\SPR{sxcsr}$ and $\SPR{uxcsr}$ are shadowed versions of said register, accessible
within specific modes.

\paragraph{The $\SPR{mxcsr}$ register}

The
$\SPR{mxcsr}$
register is a machine mode CSR is responsible for
 inspecting (e.g., feature identification)
and 
controlling (e.g., supervisor and user mode access)
\XCID.
In combination, \REFTAB{tab:mxcsr} and \REFFIG{fig:mxcsr} provide an
overview of the register.

\begin{itemize}

\item The 
      $\SPR{mxcsr}[*][\ID{U}]$
      and
      $\SPR{mxcsr}[*][\ID{S}]$
      fields control \XCID wrt. user and supervisor mode respectively.  
      Imagine an \XCID instruction is executed in 
      user                         (resp. supervisor) 
      mode: if 
      $\SPR{mxcsr}[*][\ID{U}] = 1$ (resp. $\SPR{mxcsr}[*][\ID{S}] = 1$)
      the instruction executes as normal, otherwise, if
      $\SPR{mxcsr}[*][\ID{U}] = 0$ (resp. $\SPR{mxcsr}[*][\ID{S}] = 0$),
      an illegal opcode exception results.
      If 
      $\SPR{mxcsr}[*][\ID{U}] = 1$
      then is {\em must} be true that
      $\SPR{mxcsr}[*][\ID{S}] = 1$;
      if the fields are updated st.
      $\SPR{mxcsr}[*][\ID{U}] = 1$
      and
      $\SPR{mxcsr}[*][\ID{U}] = 1$,
      an illegal opcode exception results.

\item The 
      $\SPR{mxcsr}[*][\ID{XS}]$
      field indicates whether or not the \XCID state is dirty (i.e., it
      has been updated), and must be preserved during a context switch;
      this field is analogous to the 
      $\SPR{mstatus}[*][\ID{FS}]$
      field described in~\cite[Section 3.1.6.5]{SCARV:RV:ISA:II:17}.
      More specifically,
      \[
      \begin{array}{l@{\;}c@{\;}rcl}
      \SPR{mxcsr}[*][\ID{XS}] &=& \RADIX{00}{2} &\rightarrow& \mbox{\XCID is disabled                                                                  } \\
      \SPR{mxcsr}[*][\ID{XS}] &=& \RADIX{01}{2} &\rightarrow& \mbox{\XCID is  enabled, state is initialised (i.e.,            values are per reset)    } \\
      \SPR{mxcsr}[*][\ID{XS}] &=& \RADIX{10}{2} &\rightarrow& \mbox{\XCID is  enabled; state is clean       (i.e., {\em   no} values have been updated)} \\
      \SPR{mxcsr}[*][\ID{XS}] &=& \RADIX{11}{2} &\rightarrow& \mbox{\XCID is  enabled; state is dirty       (i.e., {\em some} values have been updated)} \\
      \end{array}
      \]
      noting that

      \begin{itemize}
      \item the encodings for
            $\SPR{mxcsr}[*][\ID{XS}]$
            mirror those for 
            $\SPR{mstatus}[*][\ID{FS}]$,
            e.g., per~\cite[Section 3.1.6.5]{SCARV:RV:ISA:II:17},
      \item where a change from
            $\SPR{mxcsr}[*][\ID{XS}] = \RADIX{00}{2}$
            to
            $\SPR{mxcsr}[*][\ID{XS}] = \RADIX{01}{2}$
            occurs, 
            the $\XCR$ register file {\em must} be reset (cf.~\REFSEC{sec:spec:instruction:xc.init}),
      \item $\SPR{mxcsr}[*][\ID{XS}]$ is deliberately located toward the
            least-significant end of $\SPR{mxcsr}$; this allows atomic 
            access via one \VERB[RV]{csrrwi} instruction, for example,
      \item in the case where
            $\SPR{mxcsr}[*][\ID{XS}] = \RADIX{00}{2}$,
            {\em all} \XCID instructions (even when executed in machine
            mode) result in an illegal opcode exception; since \XCID is
            essentially disabled, this fact {\em may} be harnessed, for 
            example, to realise a form of power saving optimisation.
      \end{itemize}            

\end{itemize}

\paragraph{The $\SPR{uxcsr}$ and $\SPR{sxcsr}$ registers}

The 
$\SPR{uxcsr}$ 
and 
$\SPR{sxcsr}$ 
registers are user and supervisor mode CSRs respectively, acting as
shadowed versions of the machine mode $\SPR{mxcsr}$.  As such, their
definition and semantics are identically, bar the following caveats:

\begin{itemize}
\item If
      $\SPR{mxcsr}[*][\ID{S}] = 0$,
      then
      $\SPR{uxcsr}$ 
      and 
      $\SPR{sxcsr}$ 
      yield  zero when read, 
      and result  in an illegal opcode exception when written.
\item If
      $\SPR{mxcsr}[*][\ID{U}] = 0$,
      then
      $\SPR{uxcsr}$ 
      yields zero when read, 
      and results in an illegal opcode exception when written.
\end{itemize}

% =============================================================================

\subsubsection{Application Binary Interface (ABI)}
\label{sec:spec:state:abi}

\begin{itemize}
\item For the purposes of the ABI, {\em all} additional state stemming from 
      \XCID is considered to be callee-save: if function $f$ calls function
      $g$, then, for example, $g$ is deemed responsible for using the stack
      to preserve (resp. restore) any content in the $\XCR$ register file 
      it destroys during execution.
\item The first eight registers, 
      i.e., $\XCR[*][0]$ through $\XCR[*][7]$, 
      are considered to be function arguments (including return values).
      All other registers, 
      i.e., $\XCR[*][8]$ upward,
      are considered to be temporaries.
\item Any $\XCR$ registers pushed to the stack should be stored in ascending 
      order.  That is, since the stack grows downwards, 
      $\XCR[*][i]$
      should be written to a lower address than
      $\XCR[*][j]$
      if $i < j$; if $i = 0$ and $j = 1$, then storing $\XCR[*][i]$ at the
      address $x$ implies storing $\XCR[*][j]$ at the address $x - 4$ for
      example.
\item Any $\XCR$ registers pushed to the stack should be stored 
      at the end of the stack frame, 
      i.e., {\em after} content associated with base ISA (plus any standard 
      extensions thereof, e.g., floating-point content).
\end{itemize}

% =============================================================================
