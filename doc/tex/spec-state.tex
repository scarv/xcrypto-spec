\subsection{\XCID state}
\label{sec:spec:state}

It is important to recognise the overhead, wrt. both 
time  (e.g., due to it needing to be context switched) 
and 
space (e.g., wrt. additional logic),
relating to {\em any} state added to RV32I by \XCID.
However, it also seems reasonable to align the trade-off(s) involved with 
existing, common cases such as ISEs for floating-point arithmetic (namely
the standard 
F~\cite[Section 8]{SCARV:RV:ISA:I:17}
and
D~\cite[Section 9]{SCARV:RV:ISA:I:17}
extensions).  The addition of a dedicated floating-point register file is
rationalised, for example, by
a) clear separation of duty,
b) additional capacity, leading, e.g., to enhanced performance,
   and
c) additional (specialised) functionality;
a similar argument is true of \XCID, but motivated by a different context
(i.e., cryptographic vs. floating-point workloads).

Note that, particularly due to the nature of workloads supported by \XCID,
challenges relating to management of additional state are important.  For
example, attack vectors such as 
LazyFP~\cite{SCARV:StePre:18}, 
which capitalises on a short-cut wrt. the overhead of context switching
x87 state, {\em must} be robustly mitigated.

% =============================================================================

\subsubsection{$\XCR$ register file}
\label{sec:spec:state:xcr}

\XCID 
demands one additional 
$16$-element, $32$-bit register file;
we refer to this as the $\XCR$ register file, distinguishing it from the
general-purpose $\GPR$ register file specified by RV32I.
Note that

\begin{itemize}
\item RV32I specifies~\cite[Section 2.1]{SCARV:RV:ISA:I:17} that
      $
      \GPR[*][0] = 0 ,
      $
      i.e., that the $0$-th $\GPR$ register is fixed to $0$: any read from 
      said register yields $0$.  The analogous special-case is {\em not} 
      true of 
      $
      \XCR[*][0] ,
      $
      the $0$-th $\XCR$ register.
\item The $\XCR$ register file is used {\em exclusively} by \XCID, but, on
      the other hand, \XCID can {\em also} use the $\GPR$ register file in 
      selected cases.  For example, it uses a $\GPR$ register as

      \begin{itemize}
      \item a source, specifically a base address, for memory accesses,
            (e.g., \VERB[RV]{xc.ld.w} and \VERB[RV]{xc.st.w}; see \REFSEC{sec:spec:instruction:xc.ld.w} and \REFSEC{sec:spec:instruction:xc.st.w}),
      \item a destination for comparison operations,
            (e.g., \VERB[RV]{xc.mequ}; see \REFSEC{sec:spec:instruction:xc.mequ}).
      \end{itemize}

      \noindent
      Doing so aligns with \REFSEC{sec:bg:concept}, where the host core is 
      pitched as a control-path for the co-processor: address computation,
      control-flow orchestration, etc. fall under the remit of the former, 
      since they can be supported by RV32I as is.
\item The $\XCR$ register file must have all values set to zero on a reset.
\end{itemize}    

% =============================================================================

\subsubsection{Control and Status Registers (CSRs)}
\label{sec:spec:state:csr}

\XCID 
Requires three additional
non-standard, CSRs~\cite[Section 2]{SCARV:RV:ISA:II:17}.
In practice one physical register is required, with different shadow
versions existing at different privilege levels.
Table \ref{tab:csr} shows the address space layout of the additional
CSRs.

\begin{table}[h]
\begin{center}
\begin{tabular}{|lcc|}
\hline
       Name      & Address         & Access     \\ \hline
$\SPR{mxcsr}$ & \RADIX{7C0}{16} & read/write \\
$\SPR{sxcsr}$ & \RADIX{DC0}{16} & read/write \\
$\SPR{uxcsr}$ & \RADIX{CC0}{16} & read       \\
\hline
\end{tabular}
\end{center}
\caption{A summary of \XCID CSRs, per~\cite[Table 2.1]{SCARV:RV:ISA:II:17}.}
\label{tab:csr}
\end{table}

\paragraph{$\SPR{mxcsr}$ Register}
The machine level \XCID CSR is responsible for:
feature identification,
state dirtiness tracking and
controlling supervisor and user level access
to the \XCID registers.
Figure \ref{fig:mxcsr} shows the layout of the bitfields within the register.
Table \ref{tab:mxcsr} describes each field of the $\SPR{mxcsr}$ in detail.

\begin{figure}[h!]
\begin{center}
\begin{bytefield}[bitwidth={1.4em},bitheight={8.0ex},endianness=big]{32}
\bitheader{0-31}               
\\
  \bitbox{15}{\rule{\width}{\height}}
& \bitbox{ 1}{\rule{\width}{\height}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $SHA3     $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $AES      $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $PACK_{16}$}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $PACK_{ 8}$}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $PACK_{ 4}$}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $PACK_{ 2}$}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $PACK_{ 1}$}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $MP       $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $BIT      $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $MEM      $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $RNG      $}}
& \bitbox{ 2}{\rotatebox{90}{\tiny $XS       $}}
& \bitbox{ 1}{\rule{\width}{\height}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $S        $}}
& \bitbox{ 1}{\rotatebox{90}{\tiny $U        $}}
\\
\end{bytefield}
\end{center}
\caption{A diagrammatic description of the $\SPR{mxcsr}$ register. Blanked out bits are reserved
and read as zero.}
\label{fig:mxcsr}
\end{figure}

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|c|c|l|}
\hline
Field        & Index  & Access & Description                                                                         \\ \hline
$U         $ & $ 0$   & WLRL   & Indicates if \XCID is accessible in user mode                                       \\
$S         $ & $ 1$   & WLRL   & Indicates if \XCID is accessible in supervisor mode                                 \\
$XS        $ & $4:3$  & R/O    & Indicates whether \XCID registers need saving on a context switch                   \\
$RNG       $ & $ 5$   & R/O    & Is RNG  feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\
$MEM       $ & $ 6$   & R/O    & Is MEM  feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\
$BIT       $ & $ 7$   & R/O    & Is BIT  feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\
$MP        $ & $ 8$   & R/O    & Is MP   feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\
$PACK_{ 1} $ & $ 9$   & R/O    & Are operations on sub-word  of $w = 32$ bits supported (set), or not (clear) \\
$PACK_{ 2} $ & $10$   & R/O    & Are operations on sub-words of $w = 16$ bits supported (set), or not (clear) \\
$PACK_{ 4} $ & $11$   & R/O    & Are operations on sub-words of $w =  8$ bits supported (set), or not (clear) \\
$PACK_{ 8} $ & $12$   & R/O    & Are operations on sub-words of $w =  4$ bits supported (set), or not (clear) \\
$PACK_{16} $ & $13$   & R/O    & Are operations on sub-words of $w =  2$ bits supported (set), or not (clear) \\
$AES       $ & $14$   & R/O    & Is AES  feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\
$SHA3      $ & $15$   & R/O    & Is SHA3 feature class, per \REFSEC{sec:bg:feature}, supported (set), or not (clear) \\ \hline
\end{tabular}
\end{center}
\caption{A tabular description of the $\SPR{mxcsr}$ register.}
\label{tab:mxcsr}
\end{table}

The $\SPR{U}$ and $\SPR{S}$ bits allow access to \XCID instructions and 
state in user and supervisor mode respectively.
If an \XCID instruction is executed in $U$ or $S$ mode, and the 
corresponding bit is set, the instruction executes as normal.
Any attempt to execute an \XCID instruction in $U$ or $S$ mode when the 
corresponding bit is clear causes an illegal opcode exception.
If $\SPR{U}$ is set, then $\SPR{S}$ must also be set. Any attempt to write
$\SPR{U}$ and $\SPR{S}$
such that $\SPR{U}=1$ and $\SPR{S}=0$ will cause an illegal opcode exception.

The $\SPR{XS}$ field is used to indicate whether \XCID state is dirty and must be saved
on a context switch.
This field is analogous to the $\SPR{FS}$ field of the $\SPR{mstatus}$ register
described in \cite[Section 3.1.6.5]{SCARV:RV:ISA:II:17}.
We put the $\SPR{XS}$ field in the low bits of the register to allow
atomic accesses with a single \VERB[RV]{csr*i} instruction, rather than needing
reads, shifts and masks from the high bits.

\begin{itemize}
\item $00$ - \XCID is disabled. All \XCID instructions raise an illegal opcode
    exception.
    Implementations may use this state \XCID to implement power saving 
    optimisations.
\item $01$ - \XCID is enabled, with all \XCID registers holding their initial
    / post-reset value.
\item $10$ - \XCID is enabled, and no state needs saving.
\item $11$ - \XCID is enabled, and state needs saving on a context switch.
\end{itemize}

These encodings mirror what is defined in
\cite[Section 3.1.6.5]{SCARV:RV:ISA:II:17}.
When the $\SPR{XS}$ bits change from $00$ to $01$, the $\XCR$ registers must be
set to their post-reset value.

Note that if \XCID is "off" as per $\SPR{XS}=0$, then even \XCID instructions
executed in machine mode will also raise illegal opcode exceptions.

\paragraph{$\SPR{sxcsr}$ and $\SPR{uxcsr}$ Registers}

The $\SPR{sxcsr}$ and $\SPR{uxcsr}$ registers act as shadows of the 
$\SPR{mxcsr}$. They behave identically except for the following points:

\begin{itemize}
\item If the $\SPR{S}$ bit of $\SPR{mxcsr}$ is clear, then the
    $\SPR{sxcsr}$ and $\SPR{uxcsr}$ CSRs read zeros when read, and
    raise an illegal opcode exception when written.
\item If the $\SPR{U}$ bit of $\SPR{mxcsr}$ is clear, then the
    $\SPR{uxcsr}$ reads zeros when read, and
    raises an illegal opcode exception when written.
\end{itemize}

% =============================================================================

\subsubsection{Application Binary Interface (ABI)}
\label{sec:spec:state:abi}

\begin{itemize}
\item For the purposes of the ABI, {\em all} additional state stemming from 
      \XCID is considered to be callee-save: if function $f$ calls function
      $g$, then, for example, $g$ is deemed responsible for using the stack
      to preserve (resp. restore) any content in the $\XCR$ register file 
      it destroys during execution.
\item The first eight registers, 
      i.e., $\XCR[*][0]$ through $\XCR[*][7]$, 
      are considered to be function arguments (including return values).
      All other registers, 
      i.e., $\XCR[*][8]$ upward,
      are considered to be temporaries.
\item Any $\XCR$ registers pushed to the stack should be stored 
      in ascending order.
      That is, since the stack grows downwards, 
      $\XCR[*][i]$
      should be written to a lower address than
      $\XCR[*][j]$
      if $i < j$; if $i = 0$ and $j = 1$, then storing $\XCR[*][i]$ at the
      address $x$ implies storing $\XCR[*][j]$ at the address $x - 4$ for
      example.
\item Any $\XCR$ registers pushed to the stack should be stored 
      at the end of the stack frame, 
      i.e., {\em after} content associated with RV32I (plus any standard 
      extensions thereof, e.g., floating-point content).
\end{itemize}

% =============================================================================
